#include "hexin_stock_broker_guangfa.h"
#include "GScopedLock.h"
#include "utility.h"

static std::string VERSION_STRING = "E065.20.71.457";

static std::string gen_first_packet(const std::string& account)
{
	unsigned char buff[] = { 0xfd, 0xfd, /* @....... */
		0xfd, 0xfd, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, /* ..000000 */
		0x38, 0x30, 0x00, 0x00, 0x0c, 0x00, 0x79, 0x6f, /* 80....yo */
		0x75, 0x61, 0x72, 0x65, 0x61, 0x64, 0x6f, 0x67, /* uareadog */
		0x0d, 0x0a, 0x0c, 0x00, 0x79, 0x6f, 0x75, 0x61, /* ....youa */
		0x72, 0x65, 0x61, 0x64, 0x6f, 0x67, 0x0d, 0x0a, /* readog.. */
		0x0c, 0x00, 0x36, 0x36, 0x36, 0x36, 0x30, 0x30, /* ..666600 */
		0x35, 0x30, 0x31, 0x32, 0x33, 0x34, 0x01, 0x00, /* 501234.. */
		0x30, 0x0e, 0x00, 0x53, 0x75, 0x70, 0x70, 0x6f, /* 0..Suppo */
		0x72, 0x74, 0x46, 0x6c, 0x61, 0x67, 0x3d, 0x31, /* rtFlag=1 */
		0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* &....... */
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */
		0x00, 0x00, 0x00 };

	memcpy(buff + 44, account.c_str(), account.size());

	return std::string((char*)buff, 141);
}

static std::string gen_second_packet(const std::string& account)
{
	unsigned char buff[] =
	{
		0xFD, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC7, 0x9C, 0x9E, 0x01,
		0x01, 0x00, 0x00, 0x00, 0x36, 0x36, 0x34, 0x30, 0x30, 0x30,
		0x30, 0x30, 0x31, 0x32, 0x33, 0x34, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x44,
		0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x45, 0x30, 0x36, 0x35,
		0x2E, 0x32, 0x30, 0x2E, 0x37, 0x31, 0x00, 0x30, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
		0x40, 0x71, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4E,
		0x44, 0x3D, 0x31, 0x2E, 0x30, 0x0A, 0x64, 0x65, 0x70, 0x74,
		0x69, 0x64, 0x3D, 0x0A, 0x68, 0x64, 0x64, 0x69, 0x6E, 0x66,
		0x6F, 0x3D, 0x0A, 0x63, 0x6C, 0x69, 0x65, 0x6E, 0x74, 0x76,
		0x65, 0x72, 0x3D, 0x45, 0x30, 0x36, 0x35, 0x2E, 0x32, 0x30,
		0x2E, 0x37, 0x31, 0x2E, 0x34, 0x35, 0x37, 0x0A, 0x63, 0x70,
		0x75, 0x69, 0x6E, 0x66, 0x6F, 0x3D, 0x49, 0x6E, 0x74, 0x65,
		0x6C, 0x28, 0x52, 0x29, 0x20, 0x43, 0x6F, 0x72, 0x65, 0x28,
		0x54, 0x4D, 0x29, 0x20, 0x69, 0x35, 0x2D, 0x34, 0x33, 0x30,
		0x38, 0x55, 0x20, 0x43, 0x50, 0x55, 0x20, 0x40, 0x20, 0x32,
		0x2E, 0x38, 0x30, 0x47, 0x48, 0x7A, 0x2A, 0x32, 0x0A, 0x64,
		0x79, 0x6E, 0x70, 0x77, 0x64, 0x3D, 0x0A, 0x63, 0x72, 0x79,
		0x70, 0x74, 0x5F, 0x6E, 0x61, 0x6D, 0x65, 0x3D, 0x41, 0x43,
		0x32, 0x0A, 0x63, 0x6F, 0x6D, 0x70, 0x75, 0x74, 0x65, 0x72,
		0x6E, 0x61, 0x6D, 0x65, 0x3D, 0x57, 0x49, 0x4E, 0x2D, 0x45,
		0x36, 0x47, 0x54, 0x4E, 0x56, 0x33, 0x53, 0x39, 0x44, 0x4F,
		0x0A, 0x64, 0x79, 0x6E, 0x73, 0x69, 0x64, 0x3D, 0x0A, 0x63,
		0x5F, 0x73, 0x75, 0x70, 0x70, 0x6F, 0x72, 0x74, 0x3D, 0x31,
		0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x30, 0x31, 0x31,
		0x31, 0x0A, 0x63, 0x6C, 0x69, 0x65, 0x6E, 0x74, 0x76, 0x65,
		0x72, 0x32, 0x3D, 0x0A, 0x6D, 0x61, 0x63, 0x69, 0x6E, 0x66,
		0x6F, 0x3D, 0x30, 0x30, 0x2D, 0x30, 0x63, 0x2D, 0x32, 0x39,
		0x2D, 0x61, 0x32, 0x2D, 0x35, 0x66, 0x2D, 0x38, 0x37, 0x3B,
		0x61, 0x63, 0x2D, 0x32, 0x39, 0x2D, 0x33, 0x61, 0x2D, 0x65,
		0x63, 0x2D, 0x34, 0x65, 0x2D, 0x32, 0x37, 0x3B, 0x0A, 0x76,
		0x65, 0x72, 0x69, 0x6E, 0x66, 0x6F, 0x3D, 0x0A, 0x70, 0x75,
		0x62, 0x6C, 0x69, 0x63, 0x69, 0x70, 0x3D, 0x31, 0x39, 0x32,
		0x5F, 0x31, 0x36, 0x38, 0x5F, 0x31, 0x37, 0x31, 0x5F, 0x31,
		0x38, 0x31, 0x0A, 0x68, 0x61, 0x72, 0x64, 0x77, 0x61, 0x72,
		0x65, 0x63, 0x6F, 0x64, 0x65, 0x3D, 0x42, 0x49, 0x4F, 0x53,
		0x3A, 0x31, 0x44, 0x30, 0x30, 0x36, 0x34, 0x33, 0x39, 0x35,
		0x41, 0x46, 0x33, 0x43, 0x37, 0x34, 0x35, 0x46, 0x36, 0x43,
		0x33, 0x31, 0x39, 0x34, 0x45, 0x39, 0x32, 0x33, 0x37, 0x33,
		0x44, 0x37, 0x41, 0x2C, 0x48, 0x44, 0x44, 0x3A, 0x45, 0x72,
		0x72, 0x3A, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x35,
		0x2C, 0x4D, 0x41, 0x43, 0x3A, 0x30, 0x30, 0x2D, 0x30, 0x43,
		0x2D, 0x32, 0x39, 0x2D, 0x41, 0x32, 0x2D, 0x35, 0x46, 0x2D,
		0x38, 0x37, 0x2C, 0x50, 0x49, 0x3A, 0x43, 0x2C, 0x4E, 0x54,
		0x46, 0x53, 0x2C, 0x31, 0x34, 0x39, 0x2C, 0x56, 0x4F, 0x4C,
		0x3A, 0x30, 0x63, 0x34, 0x32, 0x36, 0x36, 0x62, 0x65, 0x2C,
		0x56, 0x4F, 0x4C, 0x4E, 0x41, 0x4D, 0x45, 0x3A, 0x0A, 0x67,
		0x75, 0x69, 0x64, 0x3D, 0x7B, 0x43, 0x39, 0x32, 0x33, 0x31,
		0x45, 0x33, 0x45, 0x2D, 0x36, 0x37, 0x38, 0x45, 0x2D, 0x34,
		0x30, 0x45, 0x44, 0x2D, 0x38, 0x44, 0x33, 0x46, 0x2D, 0x37,
		0x35, 0x34, 0x30, 0x33, 0x46, 0x34, 0x35, 0x39, 0x39, 0x37,
		0x37, 0x7D, 0x0A, 0x6D, 0x65, 0x6E, 0x75, 0x69, 0x64, 0x3D,
		0x30, 0x0A, 0x73, 0x63, 0x64, 0x6D, 0x3D, 0x30, 0x0A, 0x6D,
		0x65, 0x6E, 0x75, 0x5F, 0x76, 0x65, 0x72, 0x3D, 0x0A, 0x63,
		0x6C, 0x69, 0x65, 0x6E, 0x74, 0x3D, 0x65, 0x78, 0x65, 0x0A,
		0x6D, 0x65, 0x6E, 0x75, 0x5F, 0x61, 0x6C, 0x6C, 0x3D, 0x30,
		0x0A, 0x6D, 0x65, 0x6E, 0x75, 0x5F, 0x61, 0x64, 0x64, 0x3D,
		0x32, 0x34, 0x38, 0x37, 0x39, 0x39, 0x31, 0x31, 0x33, 0x39,
		0x0A, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x69, 0x70, 0x3D,
		0x31, 0x38, 0x33, 0x2E, 0x36, 0x32, 0x2E, 0x32, 0x34, 0x36,
		0x2E, 0x31, 0x34, 0x35, 0x0A, 0x65, 0x78, 0x74, 0x72, 0x61,
		0x3D, 0x30, 0x0A, 0x76, 0x6F, 0x6C, 0x75, 0x6D, 0x65, 0x5F,
		0x6C, 0x61, 0x62, 0x6C, 0x65, 0x3D, 0x30, 0x63, 0x34, 0x32,
		0x36, 0x36, 0x62, 0x65, 0x0A, 0x6C, 0x6F, 0x63, 0x61, 0x6C,
		0x69, 0x70, 0x3D, 0x31, 0x39, 0x32, 0x5F, 0x31, 0x36, 0x38,
		0x5F, 0x31, 0x37, 0x31, 0x5F, 0x31, 0x38, 0x31, 0x0A, 0x67,
		0x64, 0x6D, 0x6D, 0x3D, 0x0A, 0x63, 0x70, 0x75, 0x69, 0x64,
		0x3D, 0x30, 0x30, 0x30, 0x34, 0x30, 0x36, 0x35, 0x31, 0x2D,
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x2D, 0x30,
		0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x0A, 0x63, 0x6C,
		0x69, 0x65, 0x6E, 0x74, 0x6E, 0x61, 0x6D, 0x65, 0x3D, 0xCD,
		0xF8, 0xC9, 0xCF, 0xBD, 0xBB, 0xD2, 0xD7, 0xD6, 0xF7, 0xB3,
		0xCC, 0xD0, 0xF2, 0x0A, 0x62, 0x69, 0x6F, 0x73, 0x5F, 0x64,
		0x61, 0x74, 0x65, 0x3D, 0x30, 0x37, 0x2F, 0x30, 0x32, 0x2F,
		0x32, 0x30, 0x31, 0x35, 0x0A, 0x76, 0x6F, 0x6C, 0x75, 0x6D,
		0x65, 0x5F, 0x6E, 0x61, 0x6D, 0x65, 0x3D, 0x0A, 0x00, 0x00,
		0x00, 0x00
	};

	int size = 0x3dc;

	time_t rawtime;
	struct tm * timeinfo;
	time(&rawtime);
	timeinfo = localtime(&rawtime);

	uint32_t time_var = ((timeinfo->tm_mday * 0x64 + timeinfo->tm_hour) * 0x64 + timeinfo->tm_min) * 0x64 + timeinfo->tm_sec;

	memcpy(buff + 0x88, &time_var, 4);
	memcpy(buff + 16 * 9, account.c_str(), account.size());

	MD5 md5(std::string((char*)buff, 0x12b));
	const char* digest_ptr = (const char*)md5.getDigest();
	memcpy(buff + 8, digest_ptr, 16);

	std::auto_ptr<char> ptr_out(new char[size + 512]);
	memset(ptr_out.get(), 0, size + 512);

	int32_t out_len = size + 512;
	int ret = compress((Bytef*)ptr_out.get() + 16, (uLongf*)&out_len, (Bytef*)buff, size);

	//TODO
	unsigned char head[2] = { 0xFD, 0xFF };
	memcpy(ptr_out.get(), head, 2);
	//memcpy(ptr_out.get() + 13 + 2, session_id, 4);
	*(ptr_out.get()  + 6) = '\x10';
	*(ptr_out.get() + 7) = '\x20';
	*(ptr_out.get() + 10) = '\x10';

	*(uint16_t*)(ptr_out.get() + 0x0e) = (uint16_t)size;
	*(uint16_t*)(ptr_out.get() + 0x0c) = (uint16_t)out_len;

	return std::string(ptr_out.get(), 16 + out_len);

	
}


static std::string recv_response(TCPSocket &s)
{
	char head_buff[13] = { 0 };

	int total_recv = 0;

	while (total_recv < 13) {
		int ret = s.recv(head_buff + total_recv, sizeof(head_buff) - total_recv);
		if (ret <= 0)
			break;
		total_recv += ret;
	}

	if (total_recv < 13) {
		throw SocketException("Connection closed", true);
	}

	int body_bytes = strtol(head_buff + 4, NULL, 16);

	std::auto_ptr<char> ptr(new char[body_bytes]);

	total_recv = 0;

	while (total_recv < body_bytes) {
		int ret = s.recv(ptr.get() + total_recv, body_bytes - total_recv);
		if (ret <= 0)
			break;
		total_recv += ret;
	}

	if (total_recv < body_bytes) {
		throw SocketException("Connection closed", true);
	}

	return std::string(ptr.get(), body_bytes);
}

static std::string recv_response_and_unzip(TCPSocket &s)
{
	std::string resp = recv_response(s);

	if (resp.size() > 4) {

		int src_size = resp.size();
		unsigned char *src = (unsigned char *)resp.c_str();

		unsigned long dest_size = *(int*)(src + 0xa);

		char uncompress_out_buffer[1024 * 16] = { 0 };

		//ret = uncompress(uncompress_out_buffer, &dest_size, src + 16, src_size - 16);
		int ret = uncompress((Bytef*)uncompress_out_buffer, &dest_size, src + 0xe, src_size - 0xe);

		return std::string(uncompress_out_buffer, dest_size);
	}
	else {
		return resp;
	}
}

static std::string recv_response_and_decrypt(TCPSocket &s, const std::string& key1, const std::string& key2)
{
	std::string resp = recv_response(s);

	if (resp.size() > 4) {

		std::auto_ptr<char> ptr(new char[resp.size()]);
		memcpy(ptr.get(), resp.c_str(), resp.size());

		int size = resp.size() - 0xa;
		unsigned char *src = (unsigned char *)ptr.get() + 0xa;

		//ret = uncompress(uncompress_out_buffer, &dest_size, src + 16, src_size - 16);
		client_en_de_crypt(src, src, &size, (unsigned char*)key1.c_str(), (unsigned char*)key2.c_str(), 1);


		src = (unsigned char *)ptr.get();

		unsigned long pkt_dest_size = *(int*)(src + 0xa);

		unsigned long dest_size = 1024*64;

		unsigned char unzip_out_buffer[1024 * 64] = { 0 };

		int ret = uncompress(unzip_out_buffer, &dest_size, src + 0xe, size - 4);

		return std::string((char*)unzip_out_buffer, dest_size);
	}
	else {
		return resp;
	}
}

static std::string get_packet_head(int body_size)
{
	char head[13] = { 0 };
	head[0] = 0xfd;
	head[1] = 0xfd;
	head[2] = 0xfd;
	head[3] = 0xfd;

	sprintf(head + 4, "%08x", body_size);

	return std::string(head, 13);
}

static std::string encrypt_packet(const char* buff, int size, const char* session_id, uint32_t& packet_index, const std::string& key1, const std::string& key2, unsigned char* secret_data)
{
	std::auto_ptr<char> ptr(new char[size]);
	memcpy(ptr.get(), buff, size);

	memcpy(ptr.get() + 2, session_id, 4);//bytes start at 2, 4bytes  session id

	time_t rawtime;
	struct tm * timeinfo;
	time(&rawtime);
	timeinfo = localtime(&rawtime);

	uint32_t time_var = ((timeinfo->tm_mday * 0x64 + timeinfo->tm_hour) * 0x64 + timeinfo->tm_min) * 0x64 + timeinfo->tm_sec;

	memcpy(ptr.get() + 0x88, &time_var, 4);
	memcpy(ptr.get() + 0x8c, &packet_index, 4);

	++packet_index;

	MD5 md5(std::string(ptr.get(), size));
	const char* digest_ptr = (const char*)md5.getDigest();
	memcpy(ptr.get() + 8, digest_ptr, 16);

	std::auto_ptr<char> ptr_out(new char[size + 512]);
	memset(ptr_out.get(), 0, size + 512);

	uint32_t out_len = size + 512;
	int ret = compress((Bytef*)ptr_out.get() + 16, (uLongf*)&out_len, (Bytef*)ptr.get(), size);

	int extend_size = (out_len + 7) / 8 * 8;

	client_en_de_crypt((unsigned char*)ptr_out.get() + 16, (unsigned char*)ptr_out.get() + 16, &extend_size, (unsigned char*)key1.c_str(), (unsigned char*)key2.c_str(), 0);

	//memccpy(ptr.get()+)
	unsigned char head[2] = { 0xFD, 0xFF };
	memcpy(ptr_out.get(), head, 2);
	memcpy(ptr_out.get() + 2, session_id, 4);
	*(ptr_out.get() + 7) = '\x30';
	*(ptr_out.get() + 10) = '\x10';

	*(uint16_t*)(ptr_out.get() + 0x0e) = (uint16_t)size;
	*(uint16_t*)(ptr_out.get() + 0x0c) = (uint16_t)out_len;

	return std::string(ptr_out.get(), 16 + extend_size);
}

static std::string get_login_packet(const std::string& account, const std::string& password, const char* session_id, uint32_t& packet_index)
{
	int len = 0x3E8;
	unsigned char bytes[] =
	{
		0xFD, 0xFF, 0x57, 0x82, 0x7F, 0x00, 0x00, 0x10, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x99, 0xAD, 0x01,
		0x02, 0x00, 0x00, 0x00, 0x36, 0x36, 0x34, 0x30, 0x30, 0x30,
		0x30, 0x30, 0x31, 0x32, 0x33, 0x34, 0x00, 0x00, 0x00, 0x00,
		0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x44,
		0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x45, 0x30, 0x36, 0x35,
		0x2E, 0x32, 0x30, 0x2E, 0x37, 0x31, 0x00, 0x30, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
		0x40, 0x71, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4E,
		0x44, 0x3D, 0x31, 0x2E, 0x30, 0x0A, 0x64, 0x65, 0x70, 0x74,
		0x69, 0x64, 0x3D, 0x0A, 0x68, 0x64, 0x64, 0x69, 0x6E, 0x66,
		0x6F, 0x3D, 0x0A, 0x63, 0x6C, 0x69, 0x65, 0x6E, 0x74, 0x76,
		0x65, 0x72, 0x3D, 0x45, 0x30, 0x36, 0x35, 0x2E, 0x32, 0x30,
		0x2E, 0x37, 0x31, 0x2E, 0x34, 0x35, 0x37, 0x0A, 0x63, 0x70,
		0x75, 0x69, 0x6E, 0x66, 0x6F, 0x3D, 0x49, 0x6E, 0x74, 0x65,
		0x6C, 0x28, 0x52, 0x29, 0x20, 0x43, 0x6F, 0x72, 0x65, 0x28,
		0x54, 0x4D, 0x29, 0x20, 0x69, 0x35, 0x2D, 0x34, 0x33, 0x30,
		0x38, 0x55, 0x20, 0x43, 0x50, 0x55, 0x20, 0x40, 0x20, 0x32,
		0x2E, 0x38, 0x30, 0x47, 0x48, 0x7A, 0x2A, 0x32, 0x0A, 0x63,
		0x72, 0x79, 0x70, 0x74, 0x5F, 0x6E, 0x61, 0x6D, 0x65, 0x3D,
		0x41, 0x43, 0x32, 0x0A, 0x63, 0x6F, 0x6D, 0x70, 0x75, 0x74,
		0x65, 0x72, 0x6E, 0x61, 0x6D, 0x65, 0x3D, 0x57, 0x49, 0x4E,
		0x2D, 0x45, 0x36, 0x47, 0x54, 0x4E, 0x56, 0x33, 0x53, 0x39,
		0x44, 0x4F, 0x0A, 0x64, 0x79, 0x6E, 0x73, 0x69, 0x64, 0x3D,
		0x0A, 0x63, 0x5F, 0x73, 0x75, 0x70, 0x70, 0x6F, 0x72, 0x74,
		0x3D, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x30,
		0x31, 0x31, 0x31, 0x0A, 0x63, 0x6C, 0x69, 0x65, 0x6E, 0x74,
		0x76, 0x65, 0x72, 0x32, 0x3D, 0x0A, 0x70, 0x74, 0x67, 0x70,
		0x5F, 0x73, 0x70, 0x74, 0x67, 0x67, 0x74, 0x3D, 0x30, 0x0A,
		0x6D, 0x61, 0x63, 0x69, 0x6E, 0x66, 0x6F, 0x3D, 0x30, 0x30,
		0x2D, 0x30, 0x63, 0x2D, 0x32, 0x39, 0x2D, 0x61, 0x32, 0x2D,
		0x35, 0x66, 0x2D, 0x38, 0x37, 0x3B, 0x61, 0x63, 0x2D, 0x32,
		0x39, 0x2D, 0x33, 0x61, 0x2D, 0x65, 0x63, 0x2D, 0x34, 0x65,
		0x2D, 0x32, 0x37, 0x3B, 0x0A, 0x76, 0x65, 0x72, 0x69, 0x6E,
		0x66, 0x6F, 0x3D, 0x0A, 0x68, 0x78, 0x75, 0x69, 0x5F, 0x76,
		0x65, 0x72, 0x3D, 0x35, 0x2E, 0x30, 0x0A, 0x70, 0x75, 0x62,
		0x6C, 0x69, 0x63, 0x69, 0x70, 0x3D, 0x31, 0x39, 0x32, 0x5F,
		0x31, 0x36, 0x38, 0x5F, 0x31, 0x37, 0x31, 0x5F, 0x31, 0x39,
		0x30, 0x0A, 0x68, 0x61, 0x72, 0x64, 0x77, 0x61, 0x72, 0x65,
		0x63, 0x6F, 0x64, 0x65, 0x3D, 0x42, 0x49, 0x4F, 0x53, 0x3A,
		0x31, 0x44, 0x30, 0x30, 0x36, 0x34, 0x33, 0x39, 0x35, 0x41,
		0x46, 0x33, 0x43, 0x37, 0x34, 0x35, 0x46, 0x36, 0x43, 0x33,
		0x31, 0x39, 0x34, 0x45, 0x39, 0x32, 0x33, 0x37, 0x33, 0x44,
		0x37, 0x41, 0x2C, 0x48, 0x44, 0x44, 0x3A, 0x45, 0x72, 0x72,
		0x3A, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x35, 0x2C,
		0x4D, 0x41, 0x43, 0x3A, 0x30, 0x30, 0x2D, 0x30, 0x43, 0x2D,
		0x32, 0x39, 0x2D, 0x41, 0x32, 0x2D, 0x35, 0x46, 0x2D, 0x38,
		0x37, 0x2C, 0x50, 0x49, 0x3A, 0x43, 0x2C, 0x4E, 0x54, 0x46,
		0x53, 0x2C, 0x31, 0x34, 0x39, 0x2C, 0x56, 0x4F, 0x4C, 0x3A,
		0x30, 0x63, 0x34, 0x32, 0x36, 0x36, 0x62, 0x65, 0x2C, 0x56,
		0x4F, 0x4C, 0x4E, 0x41, 0x4D, 0x45, 0x3A, 0x0A, 0x67, 0x75,
		0x69, 0x64, 0x3D, 0x7B, 0x43, 0x39, 0x32, 0x33, 0x31, 0x45,
		0x33, 0x45, 0x2D, 0x36, 0x37, 0x38, 0x45, 0x2D, 0x34, 0x30,
		0x45, 0x44, 0x2D, 0x38, 0x44, 0x33, 0x46, 0x2D, 0x37, 0x35,
		0x34, 0x30, 0x33, 0x46, 0x34, 0x35, 0x39, 0x39, 0x37, 0x37,
		0x7D, 0x0A, 0x6D, 0x65, 0x6E, 0x75, 0x69, 0x64, 0x3D, 0x30,
		0x0A, 0x73, 0x63, 0x64, 0x6D, 0x3D, 0x30, 0x0A, 0x6D, 0x65,
		0x6E, 0x75, 0x5F, 0x76, 0x65, 0x72, 0x3D, 0x0A, 0x63, 0x6C,
		0x69, 0x65, 0x6E, 0x74, 0x3D, 0x65, 0x78, 0x65, 0x0A, 0x6A,
		0x64, 0x6D, 0x6D, 0x3D, 0x31, 0x0A, 0x6D, 0x65, 0x6E, 0x75,
		0x5F, 0x61, 0x6C, 0x6C, 0x3D, 0x30, 0x0A, 0x6D, 0x65, 0x6E,
		0x75, 0x5F, 0x61, 0x64, 0x64, 0x3D, 0x32, 0x34, 0x38, 0x37,
		0x39, 0x39, 0x31, 0x31, 0x33, 0x39, 0x0A, 0x73, 0x65, 0x72,
		0x76, 0x65, 0x72, 0x69, 0x70, 0x3D, 0x31, 0x38, 0x33, 0x2E,
		0x36, 0x32, 0x2E, 0x32, 0x34, 0x36, 0x2E, 0x31, 0x34, 0x35,
		0x0A, 0x76, 0x6F, 0x6C, 0x75, 0x6D, 0x65, 0x5F, 0x6C, 0x61,
		0x62, 0x6C, 0x65, 0x3D, 0x30, 0x63, 0x34, 0x32, 0x36, 0x36,
		0x62, 0x65, 0x0A, 0x6C, 0x6F, 0x63, 0x61, 0x6C, 0x69, 0x70,
		0x3D, 0x31, 0x39, 0x32, 0x5F, 0x31, 0x36, 0x38, 0x5F, 0x31,
		0x37, 0x31, 0x5F, 0x31, 0x39, 0x30, 0x0A, 0x63, 0x70, 0x75,
		0x69, 0x64, 0x3D, 0x30, 0x30, 0x30, 0x34, 0x30, 0x36, 0x35,
		0x31, 0x2D, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30,
		0x2D, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x0A,
		0x63, 0x6C, 0x69, 0x65, 0x6E, 0x74, 0x6E, 0x61, 0x6D, 0x65,
		0x3D, 0xCD, 0xF8, 0xC9, 0xCF, 0xBD, 0xBB, 0xD2, 0xD7, 0xD6,
		0xF7, 0xB3, 0xCC, 0xD0, 0xF2, 0x0A, 0x62, 0x69, 0x6F, 0x73,
		0x5F, 0x64, 0x61, 0x74, 0x65, 0x3D, 0x30, 0x37, 0x2F, 0x30,
		0x32, 0x2F, 0x32, 0x30, 0x31, 0x35, 0x0A, 0x76, 0x6F, 0x6C,
		0x75, 0x6D, 0x65, 0x5F, 0x6E, 0x61, 0x6D, 0x65, 0x3D, 0x0A,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};

	memcpy(bytes + 9 * 16, account.c_str(), account.size());
	memcpy(bytes + 10 * 16, password.c_str(), password.size());

	return std::string((char*)bytes, len);
}

static std::string get_query_gddm_packet(const std::string& account, const std::string& password, const std::string& name, const std::string& fund_account)
{
	int len = 0x1a0;
	unsigned char bytes[] =
	{
		0xFD, 0xFF, 0x34, 0x0D, 0x43, 0x00, 0x05, 0x06, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x47, 0xBD, 0x01,
		0x03, 0x00, 0x00, 0x00, 0x36, 0x36, 0x34, 0x30, 0x30, 0x30,
		0x30, 0x30, 0x31, 0x32, 0x33, 0x34, 0x00, 0x00, 0x00, 0x00,
		0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x54, 0xED, 0x3E, 0x93, 0x00, 0x00,
		0x00, 0x00, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x44,
		0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0xB0, 0xC0, 0xC0, 0xF0,
		0xB0, 0xA0, 0x00, 0x2E, 0x37, 0x31, 0x00, 0x30, 0x20, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};

	memcpy(bytes + 9 * 16, account.c_str(), account.size());
	memcpy(bytes + 10 * 16, password.c_str(), password.size());
	memcpy(bytes + 12 * 16, fund_account.c_str(), fund_account.size());
	memcpy(bytes + 16 * 16, name.c_str(), name.size());

	std::ostringstream oss;
	oss << "ND=1.0\x0A";
	oss << "addquery=0" <<"\x0A";
	oss << "zjzh="<<fund_account<<"\x0A";
	oss << "ini_ver=\x0A";
	oss << "clientver="<< VERSION_STRING <<"\x0A";
	oss << "gdxm=" << name << "\x0A";
	oss << "lxfs=\x0A";
	oss << "menuid=0\x0A";
	oss << "scdm=0"<< "\x0A";
	oss << "client=exe\x0A";
	oss << "gdzh=\x0A";

	len = sizeof(bytes);

	return std::string((char*)bytes, len) + oss.str();

}

static std::string get_account_balance_packet(const std::string& account, const std::string& password, const std::string& name, const std::string& gddm, const std::string& fund_account)
{
	
	int len = 0x190;

	unsigned char bytes[] =
	{
		0xFD, 0xFF, 0xB3, 0x22, 0x43, 0x00, 0x05, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xEA, 0x77, 0xCB, 0x01,
		0x0C, 0x00, 0x00, 0x00, 0x36, 0x36, 0x34, 0x30, 0x30, 0x30,
		0x30, 0x30, 0x31, 0x32, 0x33, 0x34, 0x00, 0x00, 0x00, 0x00,
		0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x44,
		0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0xB1, 0xC2, 0xC3, 0xF4,
		0x00, 0x00, 0x00, 0x2E, 0x37, 0x31, 0x00, 0x32, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x41, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36,
		0x37, 0x38, 0x39, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};

	memcpy(bytes + 9 * 16, account.c_str(), account.size());
	memcpy(bytes + 10 * 16, password.c_str(), password.size());
	memcpy(bytes + 12 * 16, fund_account.c_str(), fund_account.size());

	memcpy(bytes + 16 * 16, name.c_str(), name.size());

	std::ostringstream oss;
	oss << "ND=1.0\x0A";
	oss << "addquery=0" << "\x0A";
	oss << "zjzh=" << fund_account << "\x0A";
	oss << "clientver=" << VERSION_STRING << "\x0A";
	oss << "hbdm=R"<< "\x0A";
	oss << "menuid=165\x0A";
	oss << "scdm=2" << "\x0A";
	oss << "client=exe\x0A";
	oss << "gdzh=" << gddm << "\x0A";

	len = sizeof(bytes);

	return std::string((char*)bytes, len) + oss.str();

}

static std::string get_account_holding_packet(const std::string& account, std::string& password, std::string& name, std::string& gddm, const std::string& fund_account)
{
	int len = 0x1A0;
	unsigned char bytes[] =
	{
		0xFD, 0xFF, 0x4E, 0x04, 0x7F, 0x00, 0x01, 0x06, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x47, 0x4A, 0xCB, 0x01,
		0x05, 0x00, 0x00, 0x00, 0x36, 0x36, 0x34, 0x30, 0x30, 0x30,
		0x30, 0x30, 0x31, 0x32, 0x33, 0x34, 0x00, 0x00, 0x00, 0x00,
		0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x44,
		0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0xB1, 0xC2, 0xC3, 0xF4,
		0x00, 0x00, 0x00, 0x2E, 0x37, 0x31, 0x00, 0x32, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x41, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36,
		0x37, 0x38, 0x39, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};

	memcpy(bytes + 9 * 16, account.c_str(), account.size());
	memcpy(bytes + 10 * 16, password.c_str(), password.size());
	memcpy(bytes + 12 * 16, fund_account.c_str(), fund_account.size());
	memcpy(bytes + 16 * 16, name.c_str(), name.size());

	memcpy(bytes + 17 * 16 + 11, gddm.c_str(), gddm.size());

	
	std::ostringstream oss;
	oss << "ND=1.0\x0A";
	oss << "addquery=0" << "\x0A";
	oss << "zjzh=" << fund_account << "\x0A";
	oss << "clientver=" << VERSION_STRING << "\x0A";
	oss << "gdxm=" << name << "\x0A";
	oss << "menuid=161\x0A";
	oss << "scdm=2" << "\x0A";
	oss << "client=exe\x0A";
	oss << "gdzh="<<gddm<<"\x0A";

	len = sizeof(bytes);

	return std::string((char*)bytes, len) + oss.str();

}


static std::string get_buy_stock_packet(const std::string& account, const std::string& password, const std::string& name, const std::string& gddm, const std::string& fund_account, char market, const std::string&sid, float price, int32_t quant)
{
	int len = 0;

	unsigned char bytes[] =
	{
		0xFD, 0xFF, 0x73, 0x99, 0x06, 0x00, 0x02, 0x01, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2C, 0xFD, 0xCB, 0x01,
		0x0A, 0x00, 0x00, 0x00, 0x36, 0x36, 0x34, 0x30, 0x30, 0x30,
		0x30, 0x30, 0x31, 0x32, 0x33, 0x34, 0x00, 0x00, 0x00, 0x00,
		0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x44,
		0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x21, 0x00, 0xB1, 0xC2, 0xC3, 0xF4,
		0x00, 0x00, 0x00, 0x2E, 0x37, 0x31, 0x00, 0x31, 0x33, 0x30,
		0x30, 0x30, 0x37, 0x32, 0x00, 0x0A, 0xD7, 0xF3, 0x41, 0x64,
		0x00, 0x00, 0x00, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36,
		0x37, 0x38, 0x39, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};

	memcpy(bytes + 9 * 16, account.c_str(), account.size());
	memcpy(bytes + 10 * 16, password.c_str(), password.size());
	memcpy(bytes + 12 * 16, fund_account.c_str(), fund_account.size());
	memcpy(bytes + 16 * 16, name.c_str(), name.size());

	memcpy(bytes + 17 * 16 + 11, gddm.c_str(), gddm.size());

	memcpy(bytes + 16 * 16 + 11, &market, 1);
	memcpy(bytes + 16 * 16 + 12, sid.c_str(), 6);
	memcpy(bytes + 17 * 16 + 3, &price, 4);
	memcpy(bytes + 17 * 16 + 7, &quant, 4);

	if (market == '1') {
		bytes[15 * 16 + 14] = 0x21;
	}
	else {
		bytes[15 * 16 + 14] = 0x11;
	}

	std::ostringstream oss;

	oss << "ND=1.0\x0A";
	oss << "addquery=0" << "\x0A";
	oss << "zjzh=" << fund_account << "\x0A";
	oss << "interact=1\x0A";
	oss << "clientver=" << VERSION_STRING <<"\x0A";
	oss << "wtsl=" << quant << "\x0A";
	oss << "lxfs=\x0A";
	oss << "menuid=161\x0A";
	oss << "scdm=" << market << "\x0A";
	oss << "plwt=0\x0A";
	oss << "client=exe\x0A";
	oss << "wtjg="<<price<< "\x0A";
	oss << "type=ptwt\x0A";
	oss << "name=\x0A";
	oss << "confirm=0\x0A";
	oss << "xd_djpp=0" << "\x0A";
	oss << "solicited=0" << "\x0A";

	len = sizeof(bytes);

	std::string tail_str = oss.str();
	int extend_size = (len+tail_str.size() + 15) / 16 * 16 - len;
	tail_str.resize(extend_size, 0);

	return std::string((char*)bytes, len) + tail_str;

}

static std::string get_market_price_buy_packet(const std::string& account, const std::string& password, const std::string& name, const std::string& gddm, const std::string& fund_account, char market, const std::string&sid, float price, int32_t quant, int price_type = 4)
{
	int len = 0x0;


	unsigned char bytes[] =
	{
		0xFD, 0xFF, 0x8C, 0x5B, 0x43, 0x00, 0x02, 0x01, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x85, 0x5E, 0x00,
		0x32, 0x00, 0x00, 0x00, 0x36, 0x36, 0x34, 0x30, 0x30, 0x30,
		0x30, 0x30, 0x31, 0x32, 0x33, 0x34, 0x00, 0x00, 0x00, 0x00,
		0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x44,
		0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x21, 0x00, 0xB1, 0xC2, 0xC3, 0xF4,
		0x00, 0x00, 0x00, 0x2E, 0x37, 0x31, 0x00, 0x31, 0x33, 0x30,
		0x30, 0x31, 0x38, 0x35, 0x00, 0x00, 0x00, 0x80, 0xBF, 0x64,
		0x00, 0x00, 0x00, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36,
		0x37, 0x38, 0x39, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};

	memcpy(bytes + 9 * 16, account.c_str(), account.size());
	memcpy(bytes + 10 * 16, password.c_str(), password.size());
	memcpy(bytes + 12 * 16, fund_account.c_str(), fund_account.size());
	memcpy(bytes + 16 * 16, name.c_str(), name.size());
	memcpy(bytes + 17 * 16 + 11, gddm.c_str(), gddm.size());

	memcpy(bytes + 16 * 16 + 11, &market, 1);
	memcpy(bytes + 16 * 16 + 12, sid.c_str(), 6);
	memcpy(bytes + 17 * 16 + 7, &quant, 4);

	if (market == '1') {
		bytes[15 * 16 + 14] = 0x21;
	}
	else {
		bytes[15 * 16 + 14] = 0x11;
	}

	std::ostringstream oss;

	oss << "ND=1.0\x0A";
	oss << "addquery=0" << "\x0A";
	oss << "zjzh=" << fund_account << "\x0A";
	oss << "interact=1\x0A";
	oss << "clientver=" << VERSION_STRING << "\x0A";
	oss << "sjwt=U"<< "\x0A";
	oss << "wtsl=" << quant << "\x0A";
	oss << "lxfs=\x0A";
	oss << "menuid=471\x0A";
	oss << "scdm=" << market << "\x0A";
	oss << "plwt=0\x0A";
	oss << "client=exe\x0A";
	oss << "wtjg=" << price << "\x0A";
	oss << "type=sjwt\x0A";
	oss << "zxjg="<<price<< "\x0A";
	oss << "name=\x0A";
	oss << "confirm=0\x0A";
	oss << "xd_djpp=0" << "\x0A";
	oss << "solicited=0" << "\x0A";

	len = sizeof(bytes);

	std::string tail_str = oss.str();
	int extend_size = (len + tail_str.size() + 15) / 16 * 16 - len;
	tail_str.resize(extend_size, 0);

	return std::string((char*)bytes, len) + tail_str;

}


static std::string get_sell_stock_packet(const std::string& account, const std::string& password, const std::string& name, const std::string& gddm, const std::string& fund_account, char market, const std::string&sid, float price, int32_t quant)
{
	int len = 0x1e0;

	unsigned char bytes[] =
	{
		0xFD, 0xFF, 0x73, 0x99, 0x06, 0x00, 0x03, 0x01, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x18, 0xCC, 0x01,
		0x11, 0x00, 0x00, 0x00, 0x36, 0x36, 0x34, 0x30, 0x30, 0x30,
		0x30, 0x30, 0x31, 0x32, 0x33, 0x35, 0x00, 0x00, 0x00, 0x00,
		0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x44,
		0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x21, 0x00, 0xB1, 0xC2, 0xC3, 0xF4,
		0x00, 0x00, 0x00, 0x2E, 0x37, 0x31, 0x00, 0x31, 0x33, 0x30,
		0x30, 0x30, 0x37, 0x32, 0x00, 0x14, 0xAE, 0xF3, 0x41, 0x64,
		0x00, 0x00, 0x00, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36,
		0x37, 0x38, 0x39, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	};

	memcpy(bytes + 9 * 16, account.c_str(), account.size());
	memcpy(bytes + 10 * 16, password.c_str(), password.size());
	memcpy(bytes + 12 * 16, fund_account.c_str(), fund_account.size());
	memcpy(bytes + 16 * 16, name.c_str(), name.size());

	memcpy(bytes + 17 * 16 + 11, gddm.c_str(), gddm.size());

	memcpy(bytes + 16 * 16 + 11, &market, 1);
	memcpy(bytes + 16 * 16 + 12, sid.c_str(), 6);
	memcpy(bytes + 17 * 16 + 3, &price, 4);
	memcpy(bytes + 17 * 16 + 7, &quant, 4);

	if (market == '1') {
		bytes[15 * 16 + 14] = 0x21;
	}
	else {
		bytes[15 * 16 + 14] = 0x11;
	}

	std::ostringstream oss;

	oss << "ND=1.0\x0A";
	oss << "addquery=0" << "\x0A";
	oss << "zjzh=" << fund_account << "\x0A";
	oss << "interact=1\x0A";
	oss << "clientver=" <<VERSION_STRING<< "\x0A";
	oss << "wtsl=" << quant << "\x0A";
	oss << "lxfs=\x0A";
	oss << "menuid=162\x0A";
	oss << "scdm=" << market << "\x0A";
	oss << "plwt=0\x0A";
	oss << "client=exe\x0A";
	oss << "wtjg=" << price << "\x0A";
	oss << "type=ptwt\x0A";
	oss << "name=\x0A";
	oss << "confirm=0\x0A";
	oss << "xd_djpp=0" << "\x0A";
	oss << "solicited=0" << "\x0A";

	len = sizeof(bytes);

	std::string tail_str = oss.str();
	int extend_size = (len + tail_str.size() + 15) / 16 * 16 - len;
	tail_str.resize(extend_size, 0);

	return std::string((char*)bytes, len) + tail_str;

}

static std::string get_market_price_sell_packet(const std::string& account, const std::string& password, const std::string& name, const std::string& gddm, const std::string& fund_account, char market, const std::string&sid, float price, int32_t quant, int price_type = 1)
{
	int len = 0x1e0;

	unsigned char bytes[] =
	{
		0xFD, 0xFF, 0x73, 0x99, 0x06, 0x00, 0x03, 0x01, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x18, 0xCC, 0x01,
		0x11, 0x00, 0x00, 0x00, 0x36, 0x36, 0x34, 0x30, 0x30, 0x30,
		0x30, 0x30, 0x31, 0x32, 0x33, 0x34, 0x00, 0x00, 0x00, 0x00,
		0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x44,
		0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x21, 0x00, 0xB1, 0xC2, 0xC3, 0xF4,
		0x00, 0x00, 0x00, 0x2E, 0x37, 0x31, 0x00, 0x31, 0x33, 0x30,
		0x30, 0x30, 0x37, 0x32, 0x00, 0x14, 0xAE, 0xF3, 0x41, 0x64,
		0x00, 0x00, 0x00, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36,
		0x37, 0x38, 0x39, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	};

	memcpy(bytes + 9 * 16, account.c_str(), account.size());
	memcpy(bytes + 10 * 16, password.c_str(), password.size());
	memcpy(bytes + 12 * 16, fund_account.c_str(), fund_account.size());
	memcpy(bytes + 16 * 16, name.c_str(), name.size());

	memcpy(bytes + 17 * 16 + 11, gddm.c_str(), gddm.size());

	memcpy(bytes + 16 * 16 + 11, &market, 1);
	memcpy(bytes + 16 * 16 + 12, sid.c_str(), 6);
	memcpy(bytes + 17 * 16 + 3, &price, 4);
	memcpy(bytes + 17 * 16 + 7, &quant, 4);

	if (market == '1') {
		bytes[15 * 16 + 14] = 0x21;
	}
	else {
		bytes[15 * 16 + 14] = 0x11;
	}

	std::ostringstream oss;

	oss << "ND=1.0\x0A";
	oss << "addquery=0" << "\x0A";
	oss << "zjzh=" << fund_account << "\x0A";
	oss << "interact=1\x0A";
	oss << "clientver=" << VERSION_STRING << "\x0A";
	oss << "sjwt=U" << "\x0A";
	oss << "wtsl=" << quant << "\x0A";
	oss << "lxfs=\x0A";
	oss << "menuid=472\x0A";
	oss << "scdm=" << market << "\x0A";
	oss << "plwt=0\x0A";
	oss << "client=exe\x0A";
	oss << "wtjg=" << price << "\x0A";
	oss << "type=sjwt\x0A";
	oss << "zxjg=" << price << "\x0A";
	oss << "name=\x0A";
	oss << "confirm=0\x0A";
	oss << "xd_djpp=0" << "\x0A";
	oss << "solicited=0" << "\x0A";

	len = sizeof(bytes);

	std::string tail_str = oss.str();
	int extend_size = (len + tail_str.size() + 15) / 16 * 16 - len;
	tail_str.resize(extend_size, 0);

	return std::string((char*)bytes, len) + tail_str;

}

static std::string get_date_string()
{
	time_t rawtime;
	struct tm * timeinfo;
	char buffer[80] = { 0 };

	time(&rawtime);
	timeinfo = localtime(&rawtime);

	strftime(buffer, 80, "%Y%m%d", timeinfo);

	return std::string(buffer);
}

//OK
static std::string get_cancel_packet(const std::string& account, const std::string& password, const std::string& name, const std::string& gddm, const std::string& fund_account, char market, const std::string&sid, const std::string& htbh)
{
	int len = 0x1c0;
	unsigned char bytes[] =
	{
		0xFD, 0xFF, 0x6A, 0x98, 0x61, 0x00, 0x04, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1B, 0xB9, 0x5D, 0x00,
		0x09, 0x00, 0x00, 0x00, 0x36, 0x36, 0x34, 0x30, 0x30, 0x30,
		0x30, 0x30, 0x31, 0x32, 0x33, 0x34, 0x00, 0x00, 0x00, 0x00,
		0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x41, 0x34, 0x36, 0x34,
		0x32, 0x37, 0x33, 0x34, 0x31, 0x35, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x44,
		0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0xB1, 0xC2, 0xC3, 0xF4,
		0x00, 0x00, 0x00, 0x2E, 0x37, 0x31, 0x00, 0x32, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC2,
		0x89, 0x25, 0x8F, 0x31, 0x31, 0x34, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};

	memcpy(bytes + 9 * 16, account.c_str(), account.size());
	memcpy(bytes + 10 * 16, password.c_str(), password.size());
	memcpy(bytes + 11 * 16, gddm.c_str(), gddm.size());
	memcpy(bytes + 12 * 16, fund_account.c_str(), fund_account.size());
	memcpy(bytes + 16 * 16, name.c_str(), name.size());

	memcpy(bytes + 17 * 16 + 11, htbh.c_str(), htbh.size());

	memcpy(bytes + 16 * 16 + 11, &market, 1);

	std::ostringstream oss;

	oss << "ND=1.0\x0A";
	oss << "addquery=0" << "\x0A";
	oss << "zjzh=" << fund_account << "\x0A";
	oss << "ctp_extend="<< "\x0A";
	oss << "zqdm="<<sid<< "\x0A";
	oss << "local_tag="<< "\x0A";
	oss << "htbh="<<htbh<< "\x0A";
	oss << "clientver=" << VERSION_STRING << "\x0A";
	oss << "wtph=" << "\x0A";
	oss << "menuid=168\x0A";
	oss << "scdm=" << market << "\x0A";
	oss << "client=exe\x0A";
	oss << "cjbh="<< "\x0A";
	oss << "gdzh="<<gddm<< "\x0A";
	oss << "cxsl="<< "\x0A";
	oss << "time="<< "\x0A";
	oss << "date=" << get_date_string() << "\x0A";
	
	len = sizeof(bytes);


	std::string ret = std::string((char*)bytes, sizeof(bytes)) + oss.str();

	int append_size = (ret.size() + 15) / 16 * 16 - ret.size();
	ret.append(append_size, 0);

	return ret;
}

static std::string get_query_all_contract_packet(const std::string& account, const std::string& password, const std::string& gddm, const std::string& fund_account)
{
	int len = 0x190;

	unsigned char bytes[] =
	{
		0xFD, 0xFF, 0x73, 0x99, 0x06, 0x00, 0x03, 0x06, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE2, 0xF6, 0xCB, 0x01,
		0x08, 0x00, 0x00, 0x00, 0x36, 0x36, 0x34, 0x30, 0x30, 0x30,
		0x30, 0x30, 0x31, 0x32, 0x33, 0x34, 0x00, 0x00, 0x00, 0x00,
		0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x44,
		0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x41, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36,
		0x37, 0x38, 0x39, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};

	memcpy(bytes + 9 * 16, account.c_str(), account.size());
	memcpy(bytes + 10 * 16, password.c_str(), password.size());
	memcpy(bytes + 12 * 16, fund_account.c_str(), fund_account.size());
	memcpy(bytes + 17 * 16 + 11, gddm.c_str(), gddm.size());

	std::ostringstream oss;
	oss << "ND=1.0\x0A";
	oss << "addquery=0" << "\x0A";
	oss << "zjzh=" << fund_account << "\x0A";
	oss << "clientver=" << VERSION_STRING << "\x0A";
	oss << "menuid=168\x0A";
	oss << "scdm=1" << "\x0A";
	oss << "page_roll=1" << "\x0A";
	oss << "client=exe\x0A";

	len = sizeof(bytes);

	return std::string((char*)bytes, len) + oss.str();

}


static std::vector<internal_order_item> parse_query_order_response(const std::string& resp, bool& success)
{
	std::vector<internal_order_item> ret;

	const char *hd_start = resp.c_str() + 20 * 16 + 1;
	uint32_t total_bytes = 0;
	memcpy(&total_bytes, hd_start - 4, 4);

	if (total_bytes <= 6) {
		success = false;
		return ret;
	}

	uint16_t item_count = 0;
	memcpy(&item_count, hd_start + 6, 2);

	uint16_t item_bytes = 0;
	memcpy(&item_bytes, hd_start + 0xc, 2);

	const char *item_start = hd_start + total_bytes - item_count * item_bytes;

	for (int i = 0; i < item_count; ++i) {
		internal_order_item oi;
		const char *cur_item_start = item_start + i * item_bytes;

		oi.order_id.assign(cur_item_start + 7 * 16 + 14);
		oi.sid.assign(cur_item_start + 16 + 8, 6);
		oi.sname.assign(cur_item_start + 32, 8);
		oi.operation.assign(cur_item_start + 48+4, 4);
		oi.day.assign(cur_item_start + 4, 8);
		oi.time.assign(cur_item_start + 12, 8);
		oi.state.assign(cur_item_start + 9*16 + 15);

		if (oi.operation == "ÂòÈë") {
			oi.operation = "buy";
		}
		else {
			oi.operation = "sell";
		}

		memcpy(&oi.price, cur_item_start + 64, 8);

		memcpy(&oi.quant, cur_item_start + 72, 4);

		memcpy(&oi.deal_quant, cur_item_start + 84, 4);

		memcpy(&oi.deal_price, cur_item_start + 88, 8);

		ret.push_back(oi);
	}

	return ret;
}

static std::string parse_place_order_response(const std::string& resp, std::string& msg, uint32_t& packet_index)
{
	std::string ret;

	uint16_t code = *(uint16_t*)(resp.c_str() + 9 * 16);

	memcpy(&packet_index, resp.c_str() + 0x8c, 4);

	if (code == 0) {
		ret.assign(resp.c_str() + 19 * 16 + 13);
		msg.assign(resp.c_str() + 9 * 16 + 2);
	}
	else {
		msg.assign(resp.c_str() + 9 * 16 + 2);
	}

	return ret;
}


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

int hexin_stock_broker_guangfa::try_recv_packet(std::string& pkt)
{
	pkt = recv_response_and_decrypt(m_socket, m_encrypt_key1, m_encrypt_key2);

	return pkt.size();
}

hexin_stock_broker_guangfa::hexin_stock_broker_guangfa(const std::vector<boost::tuple<std::string, uint16_t>> &server_vec, const std::string& account, const std::string& password1, const std::string& password2, bool wait_response)
	:
	m_wait_response(wait_response),
	m_server_vec(server_vec),
	m_account(account),
	m_password(password1),
	m_login(false),
	m_comm_password(password2),
	m_waiting_holding_resp(false),
	m_waiting_balance_resp(false),
	m_waiting_get_order_resp(false)
{
	if (m_account.size() < 12) {
		m_account.resize(12, 0);
	}
}

hexin_stock_broker_guangfa::~hexin_stock_broker_guangfa()
{

}

std::string hexin_stock_broker_guangfa::get_account()
{
	ScopedLock lck(m_critical_sec);

	return m_account;
}

int hexin_stock_broker_guangfa::login()
{
	m_waiting_holding_resp = false;
	m_waiting_balance_resp = false;
	m_waiting_get_order_resp = false;
	
	m_login = false;

	try {
		boost::tuple<std::string, uint16_t> server_tuple = DetectBestServer(m_server_vec);
		m_server = server_tuple.get<0>();
		m_port = server_tuple.get<1>();

		m_socket.connect(m_server, m_port);

		uint8_t key1_out_buff[24] = { 0 };
		gen_key1(key1_out_buff, (uint8_t*)m_account.c_str());
		m_encrypt_key1.assign((char*)key1_out_buff, 24);

		m_last_msg = "send first packet";
		std::string first_packet = gen_first_packet(m_account);

		m_socket.send(first_packet.c_str(), first_packet.size());

		std::cout << "first step" << endl;

		std::string first_ret = recv_response(m_socket);

		m_last_msg = "send second packet";

		std::string second_packet = gen_second_packet(m_account);
		second_packet = get_packet_head(second_packet.size()) + second_packet;
		m_socket.send(second_packet.c_str(), second_packet.size());
		std::cout << "second step" << endl;


		std::string ret_str = recv_response_and_unzip(m_socket);

		memcpy(m_session_id, ret_str.c_str() + 2, 4);

		m_encrypt_key2.assign(ret_str.c_str() + 0x13d, 8);

		m_decrypt_key1 = m_encrypt_key1;
		m_decrypt_key2 = m_encrypt_key2;

		/*
		memcpy(m_decrypt_out_buff, ret_str.c_str() + 0x13f, 0x5a0);

		int32_t src_len = 0x5a0;
		server_en_de_crypt(m_decrypt_out_buff, m_decrypt_out_buff, &src_len, (uint8_t*)m_decrypt_key1.c_str(), (uint8_t*)m_decrypt_key2.c_str(), 1);

		uint8_t origin_md5[16] = { 0 };
		memcpy(origin_md5, m_decrypt_out_buff, 16);

		memcpy(m_decrypt_out_buff, m_decrypt_out_buff + 16, 0x590);

		MD5 md5_of_decrypt(std::string((char*)m_decrypt_out_buff, 0x590));
		const char* current_md5 = (const char*)md5_of_decrypt.getDigest();

		uint8_t key2_out_buff[16] = { 0 };
		int32_t key2_out_len = 0;

		gen_key2((unsigned char*)ret_str.c_str() + 0x8E1, len_4_hash, key2_out_buff, &key2_out_len, m_decrypt_out_buff);
		m_encrypt_key2.assign((char*)key2_out_buff, key2_out_len);
		*/

		//now login
		m_last_msg = "send login request";
		std::cout << "send login request" << endl;
		
		send_login_packet();

		std::string resp = recv_response_and_decrypt(m_socket, m_encrypt_key1, m_encrypt_key2);

		while (resp.size() == 4) {
			resp = recv_response_and_decrypt(m_socket, m_encrypt_key1, m_encrypt_key2);
		}
		uint16_t retcode = *(uint16_t*)(resp.c_str() + 9 * 16);
		if (retcode != 0) {
			m_last_msg.assign(resp.c_str() + 9 * 16 + 2);
			return -1;
		}

		m_account_name = resp.c_str() + 0x132;
		m_account_name.resize(6, 0);

		m_fund_account = resp.c_str() + 15 * 16 + 2;

		m_last_msg = "query gddm";
		std::cout << "query gddm" << endl;


		send_get_gddm_packet();

		resp = recv_response_and_decrypt(m_socket, m_encrypt_key1, m_encrypt_key2);

		while (resp.size() == 4) {
			resp = recv_response_and_decrypt(m_socket, m_encrypt_key1, m_encrypt_key2);
		}

		char shag[] = { 0xc9, 0xcf, 0xba, 0xa3, 0xa3, 0xc1, 0xb9, 0xc9, 0x00 };
		char szag[] = { 0xc9, 0xee, 0xdb, 0xda, 0xa3, 0xc1, 0xb9, 0xc9, 0x00 };
		//get gddm list
		int start_pos = 0;
		int pos = resp.find(shag, start_pos);
		while (pos != -1) {
			m_sh_gddm_list.push_back(resp.substr(pos - 64 - 10, 10));
			start_pos = pos + 3;
			pos = resp.find(shag, start_pos);
		}

		start_pos = 0;
		pos = resp.find(szag, start_pos);
		while (pos != -1) {
			m_sz_gddm_list.push_back(resp.substr(pos - 64 - 10, 10));
			start_pos = pos + 3;
			pos = resp.find(szag, start_pos);
		}

		if (m_sz_gddm_list.size() == 0 || m_sh_gddm_list.size() == 0) {
			m_last_msg = "query gddm failed";

			return -1;
		}


		int ret = send_get_account_holding();
		resp = recv_response_and_decrypt(m_socket, m_encrypt_key1, m_encrypt_key2);
		while (resp.size() == 4 || resp[6] != 0x01) {
			resp = recv_response_and_decrypt(m_socket, m_encrypt_key1, m_encrypt_key2);
		}
		ret = handle_get_holding_response(resp);

		ret = send_get_account_balance();
		resp = recv_response_and_decrypt(m_socket, m_encrypt_key1, m_encrypt_key2);
		while (resp.size() == 4 || resp[6] != 0x05 || resp[7] != '\x80') {
			resp = recv_response_and_decrypt(m_socket, m_encrypt_key1, m_encrypt_key2);
		}
		ret = handle_get_balance_response(resp);

		ret = send_get_account_all_order();
		resp = recv_response_and_decrypt(m_socket, m_encrypt_key1, m_encrypt_key2);
		while (resp.size() == 4 || resp[6] != 0x03 || resp[7] != '\x86') {
			resp = recv_response_and_decrypt(m_socket, m_encrypt_key1, m_encrypt_key2);
		}
		ret = handle_all_order_response(resp);

		m_last_msg = "login success";

		cout << m_last_msg << endl;

		m_login = true;

		return 0;
	}
	catch(std::exception& e)
	{
		m_last_msg = e.what();
		return -1;
	}
	catch (...) {
		return -1;
	}
}

void hexin_stock_broker_guangfa::logout()
{
	m_login = false;

	m_socket.close();

	ScopedLock lck(m_critical_sec);

	std::map<std::string, order_state>::iterator iter;
	for (iter = m_pending_order_map.begin(); iter != m_pending_order_map.end(); ) {
		if (iter->second.state == "waiting") {
			iter->second.state = "failed";
			m_completed_order_map[iter->second.user_order_id] = iter->second;
			iter = m_pending_order_map.erase(iter);
		}
		else {
			++iter;
		}
	}
}

std::string hexin_stock_broker_guangfa::create_order(const std::string& operation, const std::string& direction, const std::string& sid, double price, int amount)
{
	order_state ostate;
	ostate.operation = operation;

	ostate.direction = direction;
	ostate.state = "waiting";
	ostate.sid = sid;
	ostate.price = price;
	ostate.quant = amount;
	ostate.user_order_id = gen_uuid();
	ostate.packet_id = m_packet_index;

	ScopedLock lck(m_critical_sec);

	m_pending_order_map[ostate.user_order_id] = ostate;

	return ostate.user_order_id;
}


void hexin_stock_broker_guangfa::buy(const std::string& sid, double price, int quant, const std::string& price_type, const std::string& user_order_id)
{
	bool found = false;
	do {
		ScopedLock lck(m_critical_sec);
		std::map<std::string, order_state>::iterator iter = m_pending_order_map.find(user_order_id);

		if (iter != m_pending_order_map.end()) {
			iter->second.packet_id = m_packet_index;
			if (iter->second.state == "waiting") {
				iter->second.state = "sending";
				found = true;
			}
		}
	} while (0);

	if (found) {
		int ret = send_buy(sid, price, quant, price_type);

		if (m_wait_response) {
			std::string resp = recv_response_and_decrypt(m_socket, m_encrypt_key1, m_encrypt_key2);

			while (resp.size() == 4 || resp[6] != 0x02 || resp[7] != '\x81') {
				resp = recv_response_and_decrypt(m_socket, m_encrypt_key1, m_encrypt_key2);
			}

			handle_buy_response(resp);
		}
	}

}

void hexin_stock_broker_guangfa::sell(const std::string& sid, double price, int quant, const std::string& price_type, const std::string& user_order_id)
{
	bool found = false;
	do {
		ScopedLock lck(m_critical_sec);
		std::map<std::string, order_state>::iterator iter = m_pending_order_map.find(user_order_id);

		if (iter != m_pending_order_map.end()) {
			iter->second.packet_id = m_packet_index;
			if (iter->second.state == "waiting") {
				iter->second.state = "sending";
				found = true;
			}
		}
	} while (0);

	if (found) {
		send_sell(sid, price, quant, price_type);

		if (m_wait_response) {
			std::string resp = recv_response_and_decrypt(m_socket, m_encrypt_key1, m_encrypt_key2);

			while (resp.size() == 4 || resp[6] != 0x03 || resp[7] != '\x81') {
				resp = recv_response_and_decrypt(m_socket, m_encrypt_key1, m_encrypt_key2);
			}
			handle_sell_response(resp);
		}
	}
}

void hexin_stock_broker_guangfa::cancel_order(const std::string& user_order_id)
{
	std::string internal_order_id;
	std::string sid;
	do {
		ScopedLock lck(m_critical_sec);

		std::map<std::string, order_state>::iterator iter = m_pending_order_map.find(user_order_id);
		if (iter != m_pending_order_map.end()) {
			internal_order_id = iter->second.internal_order_id;
			sid = iter->second.sid;

			if (iter->second.state == "waiting") {
				iter->second.state = "canceled";
				m_completed_order_map[iter->second.user_order_id] = iter->second;
				m_pending_order_map.erase(iter->second.user_order_id);
			}
			else {
				iter->second.state = "canceling";
			}
		}
		else if (m_completed_order_map.find(user_order_id) != m_completed_order_map.end()) {
			//
			return;
		}
		else {
			cout << "order " << user_order_id << " not found in record" << endl;
			return;
		}

	} while (0);

	if (internal_order_id != "") {
		cout << "cancel " << internal_order_id << " " << sid << endl;
		send_cancel(internal_order_id, sid);

		if (m_wait_response) {
			std::string resp = recv_response_and_decrypt(m_socket, m_encrypt_key1, m_encrypt_key2);
			while (resp.size() == 4 || resp[6] != 0x04 || resp[7] != '\x80') {
				resp = recv_response_and_decrypt(m_socket, m_encrypt_key1, m_encrypt_key2);
			}
			handle_cancel_response(resp);
		}
	}



	/*
	while (resp.size() == 4 || resp[6] != 0x04) {
		resp = recv_response_and_decrypt(m_socket, m_encrypt_key1, m_encrypt_key2);
	}
	*/
	//
}

std::vector<order_state> hexin_stock_broker_guangfa::get_all_order()
{
	ScopedLock lck(m_critical_sec);

	std::vector<order_state> order_vec;

	std::map<std::string, order_state>::iterator iter;
	for (iter = m_pending_order_map.begin(); iter != m_pending_order_map.end(); ++iter) {
		order_vec.push_back(iter->second);
	}
	for (iter = m_completed_order_map.begin(); iter != m_completed_order_map.end(); ++iter) {
		order_vec.push_back(iter->second);
	}

	return order_vec;
}

order_state hexin_stock_broker_guangfa::get_order_state(const std::string& user_order_id)
{
	ScopedLock lck(m_critical_sec);

	if (m_pending_order_map.find(user_order_id) != m_pending_order_map.end()) {
		return m_pending_order_map[user_order_id];
	}

	if (m_completed_order_map.find(user_order_id) != m_completed_order_map.end()) {
		return m_completed_order_map[user_order_id];
	}

	return order_state();
}

std::vector<holding_item> hexin_stock_broker_guangfa::get_holding_stock()
{
	ScopedLock lck(m_critical_sec);

	return m_holding_stock;
	/*
	std::string resp = recv_response_and_decrypt(m_socket, m_encrypt_key1, m_encrypt_key2);

	while (resp.size() == 4 || resp[6] != 0x01) {
		resp = recv_response_and_decrypt(m_socket, m_encrypt_key1, m_encrypt_key2);
	}
	*/
	
}

std::vector<double> hexin_stock_broker_guangfa::get_money_left()
{
	//pkt4
	//get balance

	std::vector<double> balance_vec;

	ScopedLock lck(m_critical_sec);

	if (m_balance.size() == 0) {
		balance_vec.push_back(0);
		balance_vec.push_back(0);
	}
	else {
		balance_vec.push_back(m_balance[0]);
		balance_vec.push_back(m_balance[5]);
	}

	return balance_vec;
}

int hexin_stock_broker_guangfa::handle_packet(const std::string& pkt)
{

	if (pkt.size() == 4) {
		return 0;
	}

	int ret = 0;

	cout << "packet " << (int)(unsigned char)pkt[6] << " " << (int)(unsigned char)pkt[7] << endl;

	if (pkt[6] == '\x02' && pkt[7] == '\x81') {
		//buy
		ret = handle_buy_response(pkt);
	}
	else if (pkt[6] == '\x03' && pkt[7] == '\x81') {
		//sell
		ret = handle_sell_response(pkt);
	}
	else if (pkt[6] == '\x03' && pkt[7] == '\x86') {
		//all order
		ret = handle_all_order_response(pkt);
	}
	else if (pkt[6] == '\x01' && pkt[7] == '\x86') {
		//all holding
		ret = handle_get_holding_response(pkt);
	}
	else if (pkt[6] == '\x05' && pkt[7] == '\x80') {
		//account balance
		ret = handle_get_balance_response(pkt);
	}
	else if (pkt[6] == '\x04' && pkt[7] == '\x80') {
		ret = handle_cancel_response(pkt);
	}
	else
	{
		cout << "unknown packet " << pkt[6] << " " << pkt[7] << endl;
	}

	return 0;
}

int hexin_stock_broker_guangfa::update_account()
{
	//cout << "update account " << endl;
	if (!m_login) {
		return 0;
	}

	std::string resp;
	int ret = 0;

	if (!m_waiting_balance_resp) {
		send_get_account_balance();
		m_waiting_balance_resp = true;
		if (m_wait_response) {
			resp = recv_response_and_decrypt(m_socket, m_encrypt_key1, m_encrypt_key2);
			while (resp.size() == 4 || resp[6] != 0x05 || resp[7] != '\x80') {
				resp = recv_response_and_decrypt(m_socket, m_encrypt_key1, m_encrypt_key2);
			}
			ret = handle_get_balance_response(resp);
		}
	}
	
	bool send = false;

	do {
		ScopedLock lck(m_critical_sec);
		if (m_pending_order_map.size() > 0) {
			send = true;
		}
	} while (0);

	if (send) {

		if (!m_waiting_holding_resp) {
			send_get_account_holding();
			m_waiting_holding_resp = true;
			if (m_wait_response) {
				resp = recv_response_and_decrypt(m_socket, m_encrypt_key1, m_encrypt_key2);
				while (resp.size() == 4 || resp[6] != 0x01) {
					resp = recv_response_and_decrypt(m_socket, m_encrypt_key1, m_encrypt_key2);
				}
				ret = handle_get_holding_response(resp);
			}
		}

		if (!m_waiting_get_order_resp) {
			send_get_account_all_order();
			m_waiting_get_order_resp = true;

			resp = recv_response_and_decrypt(m_socket, m_encrypt_key1, m_encrypt_key2);
			while (resp.size() == 4 || resp[6] != 0x03 || resp[7] != '\x86') {
				resp = recv_response_and_decrypt(m_socket, m_encrypt_key1, m_encrypt_key2);
			}
			ret = handle_all_order_response(resp);
		}
	}

	return 0;
}

int hexin_stock_broker_guangfa::send_login_packet()
{
	std::string login_pkt = get_login_packet(m_account, m_password, m_session_id, m_packet_index);
	std::string encrypt_login_pkt = encrypt_packet(login_pkt.c_str(), login_pkt.size(), m_session_id, m_packet_index, m_encrypt_key1, m_encrypt_key2, NULL);
	std::string head = get_packet_head(encrypt_login_pkt.size());

	std::string whole_pkt = head + encrypt_login_pkt;

	m_socket.send(whole_pkt.c_str(), whole_pkt.size());

	return 0;
}

int hexin_stock_broker_guangfa::send_get_gddm_packet()
{
	//query gddm, pkt3
	std::string pkt3 = get_query_gddm_packet(m_account, m_password, m_account_name, m_fund_account);
	std::string encrypt_pkt_3 = encrypt_packet(pkt3.c_str(), pkt3.size(), m_session_id, m_packet_index, m_encrypt_key1, m_encrypt_key2, NULL);
	std::string head = get_packet_head(encrypt_pkt_3.size());

	std::string whole_pkt = head + encrypt_pkt_3;

	m_socket.send(whole_pkt.c_str(), whole_pkt.size());

	return 0;
}

int hexin_stock_broker_guangfa::send_get_account_holding()
{
	std::string pkt5 = get_account_holding_packet(m_account, m_password, m_account_name, m_sh_gddm_list[0], m_fund_account);
	std::string encrypt_pkt_5 = encrypt_packet(pkt5.c_str(), pkt5.size(), m_session_id, m_packet_index, m_encrypt_key1, m_encrypt_key2, NULL);

	std::string head = get_packet_head(encrypt_pkt_5.size());

	std::string whole_pkt = head + encrypt_pkt_5;

	m_socket.send(whole_pkt.c_str(), whole_pkt.size());

	return 0;
}

int hexin_stock_broker_guangfa::handle_get_holding_response(const std::string& resp)
{
	m_waiting_holding_resp = false;
	
	std::vector<holding_item> holding_stock;

	//char test[] = { 0xce, 0xde, 0xd0, 0xa7, 0xc7, 0xeb, 0xc7, 0xf3, 0x00 };

	const char *hd_start = resp.c_str() + 20 * 16 + 1;
	uint32_t total_bytes = 0;
	memcpy(&total_bytes, hd_start - 4, 4);

	if (total_bytes <= 6) {
		return 0;
	}

	uint16_t holding_count = 0;
	memcpy(&holding_count, hd_start + 6, 2);

	uint16_t item_bytes = 0;
	memcpy(&item_bytes, hd_start + 0xc, 2);

	const char *holding_start = hd_start + total_bytes - holding_count * item_bytes;

	for (int i = 0; i < holding_count; ++i) {
		holding_item hi;
		hi.sid.assign(holding_start + i * item_bytes + 28, 6);
		hi.sname.assign(holding_start + i * item_bytes + 36, 8);

		uint32_t quant = 0;
		uint32_t quant_available = 0;
		memcpy(&quant, holding_start + i * item_bytes + 56, 4);
		memcpy(&quant_available, holding_start + i * item_bytes + 60, 4);

		hi.quant = quant;
		hi.quant_available = quant_available;

		memcpy(&hi.buy_price, holding_start + i * item_bytes + 72, 8);

		holding_stock.push_back(hi);
	}

	ScopedLock lck(m_critical_sec);

	m_holding_stock = holding_stock;

	return 0;
}

int hexin_stock_broker_guangfa::send_get_account_balance()
{
	std::string pkt4 = get_account_balance_packet(m_account, m_password, m_account_name, m_sh_gddm_list[0], m_fund_account);
	std::string encrypt_pkt_4 = encrypt_packet(pkt4.c_str(), pkt4.size(), m_session_id, m_packet_index, m_encrypt_key1, m_encrypt_key2, NULL);

	std::string head = get_packet_head(encrypt_pkt_4.size());

	std::string whole_pkt = head + encrypt_pkt_4;

	m_socket.send(whole_pkt.c_str(), whole_pkt.size());

	return 0;
}

int hexin_stock_broker_guangfa::handle_get_balance_response(const std::string& resp)
{
	m_waiting_balance_resp = false;

	double db1, db2, db3, db4, db5, db6;

	memcpy(&db1, resp.c_str() + 10 * 16 + 14, 8);
	memcpy(&db2, resp.c_str() + 11 * 16 + 6, 8);
	memcpy(&db3, resp.c_str() + 11 * 16 + 14, 8);
	memcpy(&db4, resp.c_str() + 12 * 16 + 6, 8);
	memcpy(&db5, resp.c_str() + 12 * 16 + 14, 8);
	memcpy(&db6, resp.c_str() + 13 * 16 + 10, 8);


	std::vector<double> balance;
	balance.push_back(db1);//total
	balance.push_back(db2);//×Ê½ðÓà¶î
	balance.push_back(db3);//froze
	balance.push_back(db4);//kequ
	balance.push_back(db5);//total
	balance.push_back(db6);//¿ÉÓÃ

	ScopedLock lck(m_critical_sec);

	m_balance = balance;

	return 0;
}

int hexin_stock_broker_guangfa::send_get_account_all_order()
{
	std::string pkt9 = get_query_all_contract_packet(m_account, m_password, m_sz_gddm_list[0], m_fund_account);
	std::string encrypt_pkt_9 = encrypt_packet(pkt9.c_str(), pkt9.size(), m_session_id, m_packet_index, m_encrypt_key1, m_encrypt_key2, NULL);
	std::string head = get_packet_head(encrypt_pkt_9.size());

	std::string whole_pkt = head + encrypt_pkt_9;

	m_socket.send(whole_pkt.c_str(), whole_pkt.size());

	return 0;

}

int hexin_stock_broker_guangfa::handle_all_order_response(const std::string& resp)
{
	m_waiting_get_order_resp = false;

	bool success;
	std::vector<internal_order_item> orders = parse_query_order_response(resp, success);
	if (!success) {
		return 0;
	}

	ScopedLock lck(m_critical_sec);
	m_all_internal_order = orders;

	for (int i = 0; i < orders.size(); ++i) {
		std::map<std::string, order_state>::iterator iter;
		bool found = false;
		for (iter = m_pending_order_map.begin(); iter != m_pending_order_map.end(); ++iter) {
			if (iter->second.internal_order_id == orders[i].order_id) {
				iter->second.deal_quant = orders[i].deal_quant;
				iter->second.deal_price = orders[i].deal_price;
				iter->second.desc = orders[i].state;
				if (orders[i].deal_quant == orders[i].quant) {
					iter->second.state = "fulfilled";

					m_completed_order_map[iter->second.user_order_id] = iter->second;
					m_pending_order_map.erase(iter);
				}
				else {
					if (orders[i].deal_quant > 0) {
						iter->second.state = "partfilled";
					}
				}
				found = true;
				break;
			}
		}

		if (!found) {
			order_state os;
			os.quant = orders[i].quant;
			os.deal_quant = orders[i].deal_quant;
			os.internal_order_id = orders[i].order_id;
			os.sid = orders[i].sid;
			os.price = orders[i].price;
			os.time = orders[i].day + " " + orders[i].time;
			os.deal_price = orders[i].deal_price;
			os.operation = orders[i].operation;
			os.desc = orders[i].state;

			std::string user_order_id = gen_uuid();
			os.user_order_id = user_order_id;

			if (os.operation == "buy") {
				os.direction = "open";
			}
			else {
				os.direction = "close";
			}

			if (orders[i].deal_quant == orders[i].quant) {
				os.state = "fulfilled";

				m_completed_order_map[user_order_id] = os;
			}
			else {
				if (orders[i].deal_quant > 0) {
					os.state = "partfilled";
					m_pending_order_map[user_order_id] = os;
				}
				else {
					if (orders[i].state == "ÒÑ³·") {
						os.state = "canceled";
						m_completed_order_map[user_order_id] = os;
					}
					else {
						os.state = "pending";
						m_pending_order_map[user_order_id] = os;
					}
				}
			}
		}
	}

	return 0;
}

int hexin_stock_broker_guangfa::send_buy(const std::string& sid, double price, int quant, const std::string& price_type)
{
	std::string gddm;
	char market = 0;

	if (sid[0] == '6') {
		market = '2';
		gddm = m_sh_gddm_list[0];
	}
	else {
		market = '1';
		gddm = m_sz_gddm_list[0];
	}

	std::string pkt7;
	if (price_type == "limit") {
		pkt7 = get_buy_stock_packet(m_account, m_password, m_account_name, gddm, m_fund_account, market, sid, price, quant);
	}
	else if (price_type == "market") {
		pkt7 = get_market_price_buy_packet(m_account, m_password, m_account_name, gddm, m_fund_account, market, sid, price, quant);
	}

	std::string encrypt_pkt_7 = encrypt_packet(pkt7.c_str(), pkt7.size(), m_session_id, m_packet_index, m_encrypt_key1, m_encrypt_key2, NULL);
	std::string head = get_packet_head(encrypt_pkt_7.size());

	std::string whole_pkt = head + encrypt_pkt_7;

	m_socket.send(whole_pkt.c_str(), whole_pkt.size());

	return 0;
}

int hexin_stock_broker_guangfa::handle_buy_response(const std::string& resp)
{
	std::string msg;
	uint32_t packet_index;

	std::string orderid = parse_place_order_response(resp, msg, packet_index);

	std::string internal_order_id;
	std::string sid;

	do {
		ScopedLock lck(m_critical_sec);
		std::map<std::string, order_state>::iterator iter = m_pending_order_map.begin();
		for (; iter != m_pending_order_map.end(); ++iter) {
			if (iter->second.packet_id == packet_index) {
				if (orderid.size() > 0) {
					iter->second.internal_order_id = orderid;
					if (iter->second.state == "sending") {
						iter->second.state = "pending";
						return 0;
					}
					else if (iter->second.state == "canceling") {

						internal_order_id = orderid;
						sid = iter->second.sid;
					}
				}
				else {
					iter->second.state = "failed";
					iter->second.desc = msg;
					m_completed_order_map[iter->second.user_order_id] = iter->second;
					m_pending_order_map.erase(iter->second.user_order_id);

				}
				break;
			}
		}
	} while (0);

	if (internal_order_id.size() > 0) {
		int ret = send_cancel(internal_order_id, sid);
	}

	return 0;
}

int hexin_stock_broker_guangfa::send_sell(const std::string& sid, double price, int quant, const std::string& price_type)
{
	std::string gddm;
	char market = 0;

	if (sid[0] == '6') {
		market = '2';
		gddm = m_sh_gddm_list[0];
	}
	else {
		market = '1';
		gddm = m_sz_gddm_list[0];
	}

	std::string pkt6;

	if (price_type == "limit") {
		pkt6 = get_sell_stock_packet(m_account, m_password, m_account_name, gddm, m_fund_account, market, sid, price, quant);
	}
	else if (price_type == "market") {
		pkt6 = get_market_price_sell_packet(m_account, m_password, m_account_name, gddm, m_fund_account, market, sid, price, quant);
	}

	std::string encrypt_pkt_6 = encrypt_packet(pkt6.c_str(), pkt6.size(), m_session_id, m_packet_index, m_encrypt_key1, m_encrypt_key2, NULL);
	std::string head = get_packet_head(encrypt_pkt_6.size());

	std::string whole_pkt = head + encrypt_pkt_6;

	m_socket.send(whole_pkt.c_str(), whole_pkt.size());

	return 0;
}

int hexin_stock_broker_guangfa::handle_sell_response(const std::string& resp)
{
	std::string msg;
	uint32_t packet_index;

	std::string orderid = parse_place_order_response(resp, msg, packet_index);

	std::string internal_order_id;
	std::string sid;

	do {
		ScopedLock lck(m_critical_sec);
		std::map<std::string, order_state>::iterator iter = m_pending_order_map.begin();
		for (; iter != m_pending_order_map.end(); ++iter) {
			if (iter->second.packet_id == packet_index) {
				if (orderid.size() > 0) {
					iter->second.internal_order_id = orderid;
					if (iter->second.state == "sending") {
						iter->second.state = "pending";
						return 0;
					}
					else if (iter->second.state == "canceling") {

						internal_order_id = orderid;
						sid = iter->second.sid;
					}
				}
				else {
					iter->second.state = "failed";
					iter->second.desc = msg;
					m_completed_order_map[iter->second.user_order_id] = iter->second;
					m_pending_order_map.erase(iter->second.user_order_id);

				}
				break;
			}
		}
	} while (0);

	if (internal_order_id.size() > 0) {
		int ret = send_cancel(internal_order_id, sid);
	}

	return 0;
}

int hexin_stock_broker_guangfa::send_cancel(const std::string& order_id, const std::string& sid)
{
	std::string gddm;
	char market = 0;

	if (sid[0] == '6') {
		market = '2';
		gddm = m_sh_gddm_list[0];
	}
	else {
		market = '1';
		gddm = m_sz_gddm_list[0];
	}

	std::string pkt8 = get_cancel_packet(m_account, m_password, m_account_name, gddm, m_fund_account, market, sid, order_id);
	std::string encrypt_pkt_8 = encrypt_packet(pkt8.c_str(), pkt8.size(), m_session_id, m_packet_index, m_encrypt_key1, m_encrypt_key2, NULL);
	std::string head = get_packet_head(encrypt_pkt_8.size());

	std::string whole_pkt = head + encrypt_pkt_8;

	m_socket.send(whole_pkt.c_str(), whole_pkt.size());

	return 0;
}

int hexin_stock_broker_guangfa::handle_cancel_response(const std::string& resp)
{
	std::string msg;
	uint32_t packet_index = 0;

	std::string internal_order_id;
	uint16_t code = *(uint16_t*)(resp.c_str() + 9 * 16);
	if (code != 0) {
		std::string msg(resp.c_str() + 9 * 16 + 2);
		return 0;
	}

	memcpy(&packet_index, resp.c_str() + 0x8c, 4);

	msg.assign(resp.c_str() + 9 * 16 + 2);
	internal_order_id.assign(resp.c_str() + 11 * 16 + 6);

	ScopedLock lck(m_critical_sec);

	std::map<std::string, order_state>::iterator iter;
	for (iter = m_pending_order_map.begin(); iter != m_pending_order_map.end(); ++iter) {
		if (iter->second.internal_order_id == internal_order_id) {
			if (code == 0) {
				iter->second.state = "canceled";
				m_completed_order_map[iter->second.user_order_id] = iter->second;
				m_pending_order_map.erase(iter->second.user_order_id);
			}
			else {
				iter->second.desc = "cancel failed";
				cout << "cancel failed, code" << code << " " << msg << endl;
			}
			break;
		}
	}

	return 0;
}