#include "hexin_stock_broker.h"
#include "utility.h"

#include <iterator>

static std::string VERSION_STRING = "E065.18.51";

static std::string gen_first_packet(const std::string& account)
{
	unsigned char buff[] = { 0xfd, 0xfd, /* @....... */
		0xfd, 0xfd, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, /* ..000000 */
		0x38, 0x30, 0x00, 0x00, 0x0c, 0x00, 0x79, 0x6f, /* 80....yo */
		0x75, 0x61, 0x72, 0x65, 0x61, 0x64, 0x6f, 0x67, /* uareadog */
		0x0d, 0x0a, 0x0c, 0x00, 0x79, 0x6f, 0x75, 0x61, /* ....youa */
		0x72, 0x65, 0x61, 0x64, 0x6f, 0x67, 0x0d, 0x0a, /* readog.. */
		0x0c, 0x00, 0x36, 0x36, 0x36, 0x36, 0x30, 0x30, /* ..666600 */
		0x35, 0x30, 0x31, 0x32, 0x33, 0x34, 0x01, 0x00, /* 501234.. */
		0x30, 0x0e, 0x00, 0x53, 0x75, 0x70, 0x70, 0x6f, /* 0..Suppo */
		0x72, 0x74, 0x46, 0x6c, 0x61, 0x67, 0x3d, 0x31, /* rtFlag=1 */
		0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* &....... */
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */
		0x00, 0x00, 0x00 };

	memcpy(buff + 44, account.c_str(), account.size());

	return std::string((char*)buff, 141);
}

static std::string gen_second_packet(const std::string& account)
{
	unsigned char buff[] = {
		0xfd, 0xfd, /* @V...... */
		0xfd, 0xfd, 0x30, 0x30, 0x30, 0x30, 0x30, 0x32, /* ..000002 */ //1
		0x66, 0x65, 0x00, 0xfd, 0xff, 0x00, 0x00, 0x00, /* fe...... */ //2
		0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ....Rl(7 */ //3
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ....\... */ //4
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* z....... */ //5
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */ //6
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */ //7
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */ //8
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */ //9
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */ //10
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */ //11
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */ //12
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */ //13
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */ //14
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */ //15
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */ //16
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */ //17
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */ //18
		0x00, 0x00, 0x00, 0x40, 0xec, 0x33, 0x01, 0x01, /* ...@.3.. */ //19
		0x00, 0x00, 0x00, 0x36, 0x36, 0x36, 0x36, 0x30, /* ...66660 */ //20
		0x30, 0x35, 0x30, 0x31, 0x32, 0x33, 0x34, 0x00, /* 0501234. */ //21
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */ //22
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */ //23
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */ //24
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */ //25
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */ //26
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */ //27
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */ //28
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x44, 0x50, /* ......DP */ //29
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */ //30
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */ //31
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */ //32
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */ //33
		0x00, 0x33, 0x00, 0x45, 0x30, 0x36, 0x35, 0x2e, /* .3.E065. */ //34
		0x31, 0x38, 0x2e, 0x35, 0x31, 0x00, 0x33, 0x00, /* 18.51.3. */ //35
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */ //36
		0x00, 0x00, 0x01, 0x40, 0x70, 0x80, 0x00, 0x00, /* ...@p... */ //37
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */ //38
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4e, 0x44, /* ......ND */ //39
		0x3d, 0x31, 0x2e, 0x30, 0x0a, 0x64, 0x65, 0x70, /* =1.0.dep */ //40
		0x74, 0x69, 0x64, 0x3d, 0x0a, 0x68, 0x64, 0x64, /* tid=.hdd */ //41
		0x69, 0x6e, 0x66, 0x6f, 0x3d, 0x0a, 0x63, 0x6c, /* info=.cl */ //42
		0x69, 0x65, 0x6e, 0x74, 0x76, 0x65, 0x72, 0x3d, /* ientver= */ //43
		0x45, 0x30, 0x36, 0x35, 0x2e, 0x31, 0x38, 0x2e, /* E065.18. */ //44
		0x35, 0x31, 0x0a, 0x63, 0x70, 0x75, 0x69, 0x6e, /* 51.cpuin */ //45
		0x66, 0x6f, 0x3d, 0x49, 0x6e, 0x74, 0x65, 0x6c, /* fo=Intel */ //46
		0x28, 0x52, 0x29, 0x20, 0x43, 0x6f, 0x72, 0x65, /* (R) Core */ //47
		0x28, 0x54, 0x4d, 0x29, 0x20, 0x69, 0x35, 0x2d, /* (TM) i5- */ //48
		0x34, 0x33, 0x30, 0x38, 0x55, 0x20, 0x43, 0x50, /* 4308U CP */ //49
		0x55, 0x20, 0x40, 0x20, 0x32, 0x2e, 0x38, 0x30, /* U @ 2.80 */ //50
		0x47, 0x48, 0x7a, 0x2a, 0x32, 0x0a, 0x63, 0x72, /* GHz*2.cr */ //51
		0x79, 0x70, 0x74, 0x5f, 0x6e, 0x61, 0x6d, 0x65, /* ypt_name */ //52
		0x3d, 0x48, 0x45, 0x58, 0x49, 0x4e, 0x0a, 0x64, /* =HEXIN.d */ //53
		0x79, 0x6e, 0x73, 0x69, 0x64, 0x3d, 0x0a, 0x63, /* ynsid=.c */ //54
		0x5f, 0x73, 0x75, 0x70, 0x70, 0x6f, 0x72, 0x74, /* _support */ //55
		0x3d, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, /* =1111111 */ //56
		0x31, 0x31, 0x31, 0x31, 0x31, 0x0a, 0x63, 0x6c, /* 11111.cl */ //57
		0x69, 0x65, 0x6e, 0x74, 0x76, 0x65, 0x72, 0x32, /* ientver2 */ //58
		0x3d, 0x0a, 0x6d, 0x61, 0x63, 0x69, 0x6e, 0x66, /* =.macinf */ //59
		0x6f, 0x3d, 0x36, 0x63, 0x2d, 0x34, 0x30, 0x2d, /* o=6c-40- */ //60
		0x30, 0x38, 0x2d, 0x61, 0x34, 0x2d, 0x36, 0x34, /* 08-a4-64 */ //61
		0x2d, 0x62, 0x62, 0x3b, 0x30, 0x30, 0x2d, 0x30, /* -bb;00-0 */ //62
		0x63, 0x2d, 0x32, 0x39, 0x2d, 0x38, 0x32, 0x2d, /* c-29-82- */ //63
		0x32, 0x31, 0x2d, 0x30, 0x63, 0x3b, 0x0a, 0x76, /* 21-0c;.v */ //64
		0x65, 0x72, 0x69, 0x6e, 0x66, 0x6f, 0x3d, 0x68, /* erinfo=h */ //65
		0x74, 0x73, 0x63, 0x30, 0x34, 0x35, 0x2e, 0x31, /* tsc045.1 */ //66
		0x38, 0x2e, 0x35, 0x34, 0x0a, 0x68, 0x78, 0x75, /* 8.54.hxu */ //67
		0x69, 0x5f, 0x76, 0x65, 0x72, 0x3d, 0x33, 0x2e, /* i_ver=3. */ //68
		0x30, 0x0a, 0x70, 0x75, 0x62, 0x6c, 0x69, 0x63, /* 0.public */ //69
		0x69, 0x70, 0x3d, 0x0a, 0x68, 0x61, 0x72, 0x64, /* ip=.hard */ //70
		0x77, 0x61, 0x72, 0x65, 0x63, 0x6f, 0x64, 0x65, /* warecode */ //71
		0x3d, 0x42, 0x49, 0x4f, 0x53, 0x3a, 0x31, 0x44, /* =BIOS:1D */ //72
		0x30, 0x30, 0x36, 0x34, 0x33, 0x39, 0x35, 0x41, /* 0064395A */ //73
		0x46, 0x33, 0x43, 0x37, 0x34, 0x35, 0x46, 0x36, /* F3C745F6 */ //74
		0x43, 0x33, 0x31, 0x39, 0x34, 0x45, 0x39, 0x32, /* C3194E92 */ //75
		0x33, 0x37, 0x33, 0x44, 0x37, 0x41, 0x2c, 0x48, /* 373D7A,H */ //76
		0x44, 0x44, 0x3a, 0x45, 0x41, 0x31, 0x32, 0x39, /* DD:EA129 */ //77
		0x35, 0x33, 0x38, 0x33, 0x32, 0x45, 0x39, 0x34, /* 53832E94 */ //78
		0x41, 0x33, 0x41, 0x31, 0x31, 0x34, 0x36, 0x34, /* A3A11464 */ //79
		0x30, 0x46, 0x46, 0x32, 0x41, 0x39, 0x43, 0x37, /* 0FF2A9C7 */ //80
		0x34, 0x36, 0x46, 0x2c, 0x4d, 0x41, 0x43, 0x3a, /* 46F,MAC: */ //81
		0x36, 0x43, 0x2d, 0x34, 0x30, 0x2d, 0x30, 0x38, /* 6C-40-08 */ //82
		0x2d, 0x41, 0x34, 0x2d, 0x36, 0x34, 0x2d, 0x42, /* -A4-64-B */ //83
		0x42, 0x0a, 0x6d, 0x65, 0x6e, 0x75, 0x69, 0x64, /* B.menuid */ //84
		0x3d, 0x30, 0x0a, 0x73, 0x63, 0x64, 0x6d, 0x3d, /* =0.scdm= */ //85
		0x30, 0x0a, 0x6d, 0x65, 0x6e, 0x75, 0x5f, 0x76, /* 0.menu_v */ //86
		0x65, 0x72, 0x3d, 0x32, 0x30, 0x31, 0x30, 0x30, /* er=20100 */ //87
		0x37, 0x30, 0x35, 0x0a, 0x63, 0x6c, 0x69, 0x65, /* 705.clie */ //88
		0x6e, 0x74, 0x3d, 0x65, 0x78, 0x65, 0x0a, 0x73, /* nt=exe.m_socket */ //89
		0x65, 0x72, 0x76, 0x65, 0x72, 0x69, 0x70, 0x3d, /* erverip= */ //90
		0x77, 0x74, 0x2e, 0x68, 0x74, 0x73, 0x63, 0x2e, /* wt.htsc. */ //91
		0x63, 0x6f, 0x6d, 0x2e, 0x63, 0x6e, 0x0a, 0x6c, /* com.cn.l */ //92
		0x6f, 0x63, 0x61, 0x6c, 0x69, 0x70, 0x3d, 0x31, /* ocalip=1 */ //93
		0x39, 0x32, 0x5f, 0x31, 0x36, 0x38, 0x5f, 0x33, /* 92_168_3 */ //94
		0x5f, 0x32, 0x39, 0x0a, 0x62, 0x69, 0x6f, 0x73, /* _29.bios */ //95
		0x5f, 0x64, 0x61, 0x74, 0x65, 0x3d, 0x30, 0x37, /* _date=07 */ //96
		0x2f, 0x30, 0x32, 0x2f, 0x32, 0x30, 0x31, 0x35, /* /02/2015 */ //97
		0x0a                                            /* . */
	};
	time_t rawtime;
	struct tm * timeinfo;
	time(&rawtime);
	timeinfo = localtime(&rawtime);
	uint32_t time_var = ((timeinfo->tm_mday * 0x64 + timeinfo->tm_hour) * 0x64 + timeinfo->tm_min) * 0x64 + timeinfo->tm_sec;

	memcpy(buff + 9 * 16 + 5, &time_var, 4);
	memcpy(buff + 9 * 16 + 13, account.c_str(), account.size());

	MD5 md5(std::string((char*)buff + 13, 0x12b));
	const char* digest_ptr = (const char*)md5.getDigest();
	memcpy(buff + 13 + 8, digest_ptr, 16);

	return std::string((char*)buff, 779);
}


static std::string recv_response(TCPSocket &s)
{
	char head_buff[13] = { 0 };

	int total_recv = 0;

	while (total_recv < 13) {
		int ret = s.recv(head_buff + total_recv, sizeof(head_buff) - total_recv);
		if (ret <= 0)
			break;
		total_recv += ret;
	}

	if (total_recv < 13) {
		throw SocketException("Connection closed", true);
	}

	int body_bytes = strtol(head_buff + 4, NULL, 16);

	std::auto_ptr<char> ptr(new char[body_bytes]);

	total_recv = 0;

	while (total_recv < body_bytes) {
		int ret = s.recv(ptr.get() + total_recv, body_bytes - total_recv);
		if (ret <= 0)
			break;
		total_recv += ret;
	}

	if (total_recv < body_bytes) {
		throw SocketException("Connection closed", true);
	}

	return std::string(ptr.get(), body_bytes);
}

static std::string recv_response_and_unzip(TCPSocket &s)
{
	std::string resp = recv_response(s);

	if (resp.size() > 4) {

		int src_size = resp.size();
		unsigned char *src = (unsigned char *)resp.c_str();

		unsigned long dest_size = *(int*)(src + 0xa);

		char uncompress_out_buffer[1024 * 16] = { 0 };

		//ret = uncompress(uncompress_out_buffer, &dest_size, src + 16, src_size - 16);
		int ret = uncompress((Bytef*)uncompress_out_buffer, &dest_size, src + 0xe, src_size - 0xe);

		return std::string(uncompress_out_buffer, dest_size);
	}
	else {
		return resp;
	}
}

static std::string recv_response_and_decrypt(TCPSocket &s, const std::string& key1, const std::string& key2)
{
	std::string resp = recv_response(s);

	if (resp.size() > 4) {

		std::auto_ptr<char> ptr(new char[resp.size()]);
		memcpy(ptr.get(), resp.c_str(), resp.size());

		int size = resp.size() - 0xa;
		unsigned char *src = (unsigned char *)ptr.get() + 0xa;

		//ret = uncompress(uncompress_out_buffer, &dest_size, src + 16, src_size - 16);
		client_en_de_crypt(src, src, &size, (unsigned char*)key1.c_str(), (unsigned char*)key2.c_str(), 1);


		src = (unsigned char *)ptr.get();

		unsigned long pkt_dest_size = *(int*)(src + 0xa);

		unsigned long dest_size = 1024*64;

		unsigned char unzip_out_buffer[1024 * 64] = { 0 };

		int ret = uncompress(unzip_out_buffer, &dest_size, src + 0xe, size - 4);

		return std::string((char*)unzip_out_buffer, dest_size);
	}
	else {
		return resp;
	}
}

static std::string get_packet_head(int body_size)
{
	char head[13] = { 0 };
	head[0] = 0xfd;
	head[1] = 0xfd;
	head[2] = 0xfd;
	head[3] = 0xfd;

	sprintf(head + 4, "%08x", body_size);

	return std::string(head, 13);
}

static std::string encrypt_packet(const char* buff, int size, const char* session_id, uint32_t& packet_index, const std::string& key1, const std::string& key2, unsigned char* secret_data)
{
	std::auto_ptr<char> ptr(new char[size]);
	memcpy(ptr.get(), buff, size);
	memcpy(ptr.get() + 2, session_id, 4);//bytes start at 2, 4bytes  session id

	time_t rawtime;
	struct tm * timeinfo;
	time(&rawtime);
	timeinfo = localtime(&rawtime);

	uint32_t time_var = ((timeinfo->tm_mday * 0x64 + timeinfo->tm_hour) * 0x64 + timeinfo->tm_min) * 0x64 + timeinfo->tm_sec;

	memcpy(ptr.get() + 0x88, &time_var, 4);
	memcpy(ptr.get() + 0x8c, &packet_index, 4);

	++packet_index;

	int32_t out_len = 0;
	uint8_t dst[0x100] = { 0 };

	signature((unsigned char*)ptr.get(), size, dst, &out_len, secret_data);

	memcpy(ptr.get() + 8, dst, out_len);//bytes at 8, 128bytes

	std::auto_ptr<char> ptr_out(new char[size + 512]);
	memset(ptr_out.get(), 0, size + 512);

	out_len = size + 512;
	int ret = compress((Bytef*)ptr_out.get() + 16, (uLongf*)&out_len, (Bytef*)ptr.get(), size);

	int extend_size = (out_len + 7) / 8 * 8;

	client_en_de_crypt((unsigned char*)ptr_out.get() + 16, (unsigned char*)ptr_out.get() + 16, &extend_size, (unsigned char*)key1.c_str(), (unsigned char*)key2.c_str(), 0);

	//memccpy(ptr.get()+)
	unsigned char head[2] = { 0xFD, 0xFF };
	memcpy(ptr_out.get(), head, 2);
	memcpy(ptr_out.get() + 2, session_id, 4);
	*(ptr_out.get() + 7) = '\x30';
	*(ptr_out.get() + 10) = '\x10';

	*(uint16_t*)(ptr_out.get() + 0x0e) = (uint16_t)size;
	*(uint16_t*)(ptr_out.get() + 0x0c) = (uint16_t)out_len;

	return std::string(ptr_out.get(), 16 + extend_size);
}

static std::string get_login_packet(const std::string& account, const std::string& password)
{
	int len = 0x318;
	unsigned char bytes[] =
	{
		0xFD, 0xFF, 0xEC, 0x47, 0xB7, 0x00, 0x00, 0x10, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x36, 0x93, 0x3E, 0x00,
		0x02, 0x00, 0x00, 0x00, 0x36, 0x36, 0x36, 0x36, 0x30, 0x30,
		0x35, 0x30, 0x31, 0x32, 0x33, 0x34, 0x00, 0x00, 0x00, 0x00,
		0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x44,
		0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x33, 0x00, 0x45, 0x30, 0x36, 0x35,
		0x2E, 0x31, 0x38, 0x2E, 0x35, 0x31, 0x00, 0x33, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
		0x40, 0x70, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4E,
		0x44, 0x3D, 0x31, 0x2E, 0x30, 0x0A, 0x64, 0x65, 0x70, 0x74,
		0x69, 0x64, 0x3D, 0x0A, 0x68, 0x64, 0x64, 0x69, 0x6E, 0x66,
		0x6F, 0x3D, 0x0A, 0x63, 0x6C, 0x69, 0x65, 0x6E, 0x74, 0x76,
		0x65, 0x72, 0x3D, 0x45, 0x30, 0x36, 0x35, 0x2E, 0x31, 0x38,
		0x2E, 0x35, 0x31, 0x0A, 0x63, 0x70, 0x75, 0x69, 0x6E, 0x66,
		0x6F, 0x3D, 0x49, 0x6E, 0x74, 0x65, 0x6C, 0x28, 0x52, 0x29,
		0x20, 0x43, 0x6F, 0x72, 0x65, 0x28, 0x54, 0x4D, 0x29, 0x20,
		0x69, 0x35, 0x2D, 0x34, 0x33, 0x30, 0x38, 0x55, 0x20, 0x43,
		0x50, 0x55, 0x20, 0x40, 0x20, 0x32, 0x2E, 0x38, 0x30, 0x47,
		0x48, 0x7A, 0x2A, 0x32, 0x0A, 0x63, 0x72, 0x79, 0x70, 0x74,
		0x5F, 0x6E, 0x61, 0x6D, 0x65, 0x3D, 0x48, 0x45, 0x58, 0x49,
		0x4E, 0x0A, 0x64, 0x79, 0x6E, 0x73, 0x69, 0x64, 0x3D, 0x0A,
		0x63, 0x5F, 0x73, 0x75, 0x70, 0x70, 0x6F, 0x72, 0x74, 0x3D,
		0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31,
		0x31, 0x31, 0x0A, 0x63, 0x6C, 0x69, 0x65, 0x6E, 0x74, 0x76,
		0x65, 0x72, 0x32, 0x3D, 0x0A, 0x70, 0x74, 0x67, 0x70, 0x5F,
		0x73, 0x70, 0x74, 0x67, 0x67, 0x74, 0x3D, 0x30, 0x0A, 0x6D,
		0x61, 0x63, 0x69, 0x6E, 0x66, 0x6F, 0x3D, 0x36, 0x63, 0x2D,
		0x34, 0x30, 0x2D, 0x30, 0x38, 0x2D, 0x61, 0x34, 0x2D, 0x36,
		0x34, 0x2D, 0x62, 0x62, 0x3B, 0x30, 0x30, 0x2D, 0x30, 0x63,
		0x2D, 0x32, 0x39, 0x2D, 0x38, 0x32, 0x2D, 0x32, 0x31, 0x2D,
		0x30, 0x63, 0x3B, 0x0A, 0x76, 0x65, 0x72, 0x69, 0x6E, 0x66,
		0x6F, 0x3D, 0x68, 0x74, 0x73, 0x63, 0x30, 0x34, 0x35, 0x2E,
		0x31, 0x38, 0x2E, 0x35, 0x34, 0x0A, 0x68, 0x78, 0x75, 0x69,
		0x5F, 0x76, 0x65, 0x72, 0x3D, 0x33, 0x2E, 0x30, 0x0A, 0x70,
		0x75, 0x62, 0x6C, 0x69, 0x63, 0x69, 0x70, 0x3D, 0x0A, 0x68,
		0x61, 0x72, 0x64, 0x77, 0x61, 0x72, 0x65, 0x63, 0x6F, 0x64,
		0x65, 0x3D, 0x42, 0x49, 0x4F, 0x53, 0x3A, 0x31, 0x44, 0x30,
		0x30, 0x36, 0x34, 0x33, 0x39, 0x35, 0x41, 0x46, 0x33, 0x43,
		0x37, 0x34, 0x35, 0x46, 0x36, 0x43, 0x33, 0x31, 0x39, 0x34,
		0x45, 0x39, 0x32, 0x33, 0x37, 0x33, 0x44, 0x37, 0x41, 0x2C,
		0x48, 0x44, 0x44, 0x3A, 0x45, 0x41, 0x31, 0x32, 0x39, 0x35,
		0x33, 0x38, 0x33, 0x32, 0x45, 0x39, 0x34, 0x41, 0x33, 0x41,
		0x31, 0x31, 0x34, 0x36, 0x34, 0x30, 0x46, 0x46, 0x32, 0x41,
		0x39, 0x43, 0x37, 0x34, 0x36, 0x46, 0x2C, 0x4D, 0x41, 0x43,
		0x3A, 0x36, 0x43, 0x2D, 0x34, 0x30, 0x2D, 0x30, 0x38, 0x2D,
		0x41, 0x34, 0x2D, 0x36, 0x34, 0x2D, 0x42, 0x42, 0x0A, 0x6D,
		0x65, 0x6E, 0x75, 0x69, 0x64, 0x3D, 0x30, 0x0A, 0x73, 0x63,
		0x64, 0x6D, 0x3D, 0x30, 0x0A, 0x6D, 0x65, 0x6E, 0x75, 0x5F,
		0x76, 0x65, 0x72, 0x3D, 0x32, 0x30, 0x31, 0x30, 0x30, 0x37,
		0x30, 0x35, 0x0A, 0x63, 0x6C, 0x69, 0x65, 0x6E, 0x74, 0x3D,
		0x65, 0x78, 0x65, 0x0A, 0x6A, 0x64, 0x6D, 0x6D, 0x3D, 0x31,
		0x0A, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x69, 0x70, 0x3D,
		0x77, 0x74, 0x2E, 0x68, 0x74, 0x73, 0x63, 0x2E, 0x63, 0x6F,
		0x6D, 0x2E, 0x63, 0x6E, 0x0A, 0x6C, 0x6F, 0x63, 0x61, 0x6C,
		0x69, 0x70, 0x3D, 0x31, 0x39, 0x32, 0x5F, 0x31, 0x36, 0x38,
		0x5F, 0x33, 0x5F, 0x32, 0x39, 0x0A, 0x62, 0x69, 0x6F, 0x73,
		0x5F, 0x64, 0x61, 0x74, 0x65, 0x3D, 0x30, 0x37, 0x2F, 0x30,
		0x32, 0x2F, 0x32, 0x30, 0x31, 0x35, 0x0A, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0xBA, 0x0D, 0xF0, 0xAD, 0xBA
	};

	memcpy(bytes + 9 * 16, account.c_str(), account.size());
	memcpy(bytes + 10 * 16, password.c_str(), password.size());

	return std::string((char*)bytes, len);
}

static std::string get_query_gddm_packet(const std::string& account, const std::string& password, const std::string& name)
{
	int len = 0x198;
	unsigned char bytes[] =
	{
		0xFD, 0xFF, 0xFB, 0x13, 0x5E, 0x00, 0x05, 0x06, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC5, 0x4F, 0x40, 0x00,
		0x03, 0x00, 0x00, 0x00, 0x36, 0x36, 0x36, 0x36, 0x30, 0x30,
		0x35, 0x30, 0x31, 0x32, 0x33, 0x34, 0x00, 0x00, 0x00, 0x00,
		0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x36, 0x36, 0x36, 0x36, 0x30, 0x30, 0x35, 0x30,
		0x31, 0x32, 0x33, 0x34, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x44,
		0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x33, 0x00, 0xB9, 0xCB, 0xC9, 0xFA,
		0xBB, 0xAA, 0x00, 0x2E, 0x35, 0x31, 0x00, 0x33, 0x20, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4E,
		0x44, 0x3D, 0x31, 0x2E, 0x30, 0x0A, 0x7A, 0x6A, 0x7A, 0x68,
		0x3D, 0x36, 0x36, 0x36, 0x36, 0x30, 0x30, 0x35, 0x30, 0x31,
		0x32, 0x33, 0x34, 0x0A, 0x69, 0x6E, 0x69, 0x5F, 0x76, 0x65,
		0x72, 0x3D, 0x32, 0x30, 0x31, 0x31, 0x30, 0x39, 0x30, 0x31,
		0x0A, 0x63, 0x6C, 0x69, 0x65, 0x6E, 0x74, 0x76, 0x65, 0x72,
		0x3D, 0x45, 0x30, 0x36, 0x35, 0x2E, 0x31, 0x38, 0x2E, 0x35,
		0x31, 0x0A, 0x6D, 0x65, 0x6E, 0x75, 0x69, 0x64, 0x3D, 0x30,
		0x0A, 0x73, 0x63, 0x64, 0x6D, 0x3D, 0x30, 0x0A, 0x63, 0x6C,
		0x69, 0x65, 0x6E, 0x74, 0x3D, 0x65, 0x78, 0x65, 0x0A, 0x67,
		0x64, 0x7A, 0x68, 0x3D, 0x0A, 0x7A, 0x63, 0x73, 0x78, 0x3D,
		0x31, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xAD, 0xBA, 0x0D, 0xF0, 0xAD, 0xBA
	};

	memcpy(bytes + 9 * 16, account.c_str(), account.size());
	memcpy(bytes + 10 * 16, password.c_str(), password.size());
	memcpy(bytes + 12 * 16, account.c_str(), account.size());
	memcpy(bytes + 16 * 16, name.c_str(), name.size());

	memcpy(bytes + 19 * 16 + 7, account.c_str(), account.size());

	return std::string((char*)bytes, len);
}

static std::string get_account_balance_packet(const std::string& account, std::string& password, std::string& name, std::string& gddm)
{
	int len = 0x198;
	unsigned char bytes[] =
	{
		//0xFD, 0xFF, 0x52, 0x6B, 0x07, 0x00, 0x05, 0x00, 0x00, 0x00,
		0xFD, 0xFF, 0x52, 0x6B, 0x07, 0x00, 0x22, 0x06, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x75, 0x31, 0x9A, 0x00,
		0x07, 0x00, 0x00, 0x00, 0x36, 0x36, 0x36, 0x36, 0x30, 0x30,
		0x35, 0x30, 0x31, 0x32, 0x33, 0x34, 0x00, 0x00, 0x00, 0x00,
		0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x36, 0x36, 0x36, 0x36, 0x30, 0x30, 0x35, 0x30,
		0x31, 0x32, 0x33, 0x34, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x44,
		0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x33, 0x00, 0xB9, 0xCB, 0xC9, 0xFA,
		0xBB, 0xAA, 0x00, 0x2E, 0x35, 0x31, 0x00, 0x32, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x41, 0x33, 0x38, 0x31, 0x30, 0x35, 0x36,
		0x37, 0x39, 0x35, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4E,
		0x44, 0x3D, 0x31, 0x2E, 0x30, 0x0A, 0x7A, 0x6A, 0x7A, 0x68,
		0x3D, 0x36, 0x36, 0x36, 0x36, 0x30, 0x30, 0x35, 0x30, 0x31,
		0x32, 0x33, 0x34, 0x0A, 0x63, 0x6C, 0x69, 0x65, 0x6E, 0x74,
		0x76, 0x65, 0x72, 0x3D, 0x45, 0x30, 0x36, 0x35, 0x2E, 0x31,
		0x38, 0x2E, 0x35, 0x31, 0x0A, 0x68, 0x62, 0x64, 0x6D, 0x3D,
		0x52, 0x0A, 0x6D, 0x65, 0x6E, 0x75, 0x69, 0x64, 0x3D, 0x31,
		0x36, 0x35, 0x0A, 0x73, 0x63, 0x64, 0x6D, 0x3D, 0x32, 0x0A,
		0x63, 0x6C, 0x69, 0x65, 0x6E, 0x74, 0x3D, 0x65, 0x78, 0x65,
		0x0A, 0x67, 0x64, 0x7A, 0x68, 0x3D, 0x41, 0x33, 0x38, 0x31,
		0x30, 0x35, 0x36, 0x37, 0x39, 0x35, 0x0A, 0x7A, 0x63, 0x73,
		0x78, 0x3D, 0x31, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x0D, 0xF0, 0xAD, 0xBA
	};

	memcpy(bytes + 9 * 16, account.c_str(), account.size());
	memcpy(bytes + 10 * 16, password.c_str(), password.size());
	memcpy(bytes + 12 * 16, account.c_str(), account.size());

	memcpy(bytes + 16 * 16, name.c_str(), name.size());

	memcpy(bytes + 19 * 16 + 7, account.c_str(), account.size());

	memcpy(bytes + 17 * 16 + 11, gddm.c_str(), gddm.size());

	memcpy(bytes + 24 * 16 + 2, gddm.c_str(), gddm.size());

	return std::string((char*)bytes, len);
}

static std::string get_account_holding_packet(const std::string& account, std::string& password, std::string& name, std::string& gddm)
{
	int len = 0x198;
	unsigned char bytes[] =
	{
		0xFD, 0xFF, 0x83, 0x5B, 0x6B, 0x00, 0x01, 0x06, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77, 0x6C, 0x9A, 0x00,
		0x08, 0x00, 0x00, 0x00, 0x36, 0x36, 0x36, 0x36, 0x30, 0x30,
		0x35, 0x30, 0x31, 0x32, 0x33, 0x34, 0x00, 0x00, 0x00, 0x00,
		0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x36, 0x36, 0x36, 0x36, 0x30, 0x30, 0x35, 0x30,
		0x31, 0x32, 0x33, 0x34, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x44,
		0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x33, 0x00, 0xB9, 0xCB, 0xC9, 0xFA,
		0xBB, 0xAA, 0x00, 0x2E, 0x35, 0x31, 0x00, 0x32, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x41, 0x33, 0x38, 0x31, 0x30, 0x35, 0x36,
		0x37, 0x39, 0x35, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4E,
		0x44, 0x3D, 0x31, 0x2E, 0x30, 0x0A, 0x7A, 0x6A, 0x7A, 0x68,
		0x3D, 0x36, 0x36, 0x36, 0x36, 0x30, 0x30, 0x35, 0x30, 0x31,
		0x32, 0x33, 0x34, 0x0A, 0x63, 0x6C, 0x69, 0x65, 0x6E, 0x74,
		0x76, 0x65, 0x72, 0x3D, 0x45, 0x30, 0x36, 0x35, 0x2E, 0x31,
		0x38, 0x2E, 0x35, 0x31, 0x0A, 0x68, 0x62, 0x64, 0x6D, 0x3D,
		0x52, 0x0A, 0x6D, 0x65, 0x6E, 0x75, 0x69, 0x64, 0x3D, 0x31,
		0x36, 0x35, 0x0A, 0x73, 0x63, 0x64, 0x6D, 0x3D, 0x32, 0x0A,
		0x63, 0x6C, 0x69, 0x65, 0x6E, 0x74, 0x3D, 0x65, 0x78, 0x65,
		0x0A, 0x67, 0x64, 0x7A, 0x68, 0x3D, 0x41, 0x33, 0x38, 0x31,
		0x30, 0x35, 0x36, 0x37, 0x39, 0x35, 0x0A, 0x7A, 0x63, 0x73,
		0x78, 0x3D, 0x31, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x0D, 0xF0, 0xAD, 0xBA
	};

	memcpy(bytes + 9 * 16, account.c_str(), account.size());
	memcpy(bytes + 10 * 16, password.c_str(), password.size());
	memcpy(bytes + 12 * 16, account.c_str(), account.size());

	memcpy(bytes + 16 * 16, name.c_str(), name.size());

	memcpy(bytes + 19 * 16 + 7, account.c_str(), account.size());

	memcpy(bytes + 17 * 16 + 11, gddm.c_str(), gddm.size());

	memcpy(bytes + 24 * 16 + 2, gddm.c_str(), gddm.size());

	return std::string((char*)bytes, len);
}


static std::string get_buy_stock_packet(const std::string& account, const std::string& password, const std::string& name, const std::string& gddm, char market, const std::string&sid, float price, int32_t quant)
{
	int len = 0x1c0;
	unsigned char bytes[] =
	{
		0xFD, 0xFF, 0x74, 0x82, 0xD0, 0x00, 0x02, 0x01, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x9B, 0x6B, 0x9B, 0x00,
		0x16, 0x00, 0x00, 0x00, 0x36, 0x36, 0x36, 0x36, 0x30, 0x30,
		0x35, 0x30, 0x31, 0x32, 0x33, 0x34, 0x00, 0x00, 0x00, 0x00,
		0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x36, 0x36, 0x36, 0x36, 0x30, 0x30, 0x35, 0x30,
		0x31, 0x32, 0x33, 0x34, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x44,
		0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x21, 0x00, 0xB9, 0xCB, 0xC9, 0xFA,
		0xBB, 0xAA, 0x00, 0x2E, 0x35, 0x31, 0x00, 0x31, 0x33, 0x30,
		0x30, 0x30, 0x37, 0x32, 0x00, 0x14, 0xAE, 0x3D, 0x42, 0xC8,
		0x00, 0x00, 0x00, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36,
		0x37, 0x38, 0x39, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4E,
		0x44, 0x3D, 0x31, 0x2E, 0x30, 0x0A, 0x7A, 0x6A, 0x7A, 0x68,
		0x3D, 0x36, 0x36, 0x36, 0x36, 0x30, 0x30, 0x35, 0x30, 0x34,
		0x34, 0x33, 0x33, 0x0A, 0x69, 0x6E, 0x74, 0x65, 0x72, 0x61,
		0x63, 0x74, 0x3D, 0x31, 0x0A, 0x63, 0x6C, 0x69, 0x65, 0x6E,
		0x74, 0x76, 0x65, 0x72, 0x3D, 0x45, 0x30, 0x36, 0x35, 0x2E,
		0x31, 0x38, 0x2E, 0x35, 0x31, 0x0A, 0x6C, 0x78, 0x66, 0x73,
		0x3D, 0x0A, 0x6D, 0x65, 0x6E, 0x75, 0x69, 0x64, 0x3D, 0x31,
		0x36, 0x31, 0x0A, 0x73, 0x63, 0x64, 0x6D, 0x3D, 0x31, 0x0A,
		0x70, 0x6C, 0x77, 0x74, 0x3D, 0x30, 0x0A, 0x63, 0x6C, 0x69,
		0x65, 0x6E, 0x74, 0x3D, 0x65, 0x78, 0x65, 0x0A, 0x74, 0x79,
		0x70, 0x65, 0x3D, 0x70, 0x74, 0x77, 0x74, 0x0A, 0x6E, 0x61,
		0x6D, 0x65, 0x3D, 0x0A, 0x63, 0x6F, 0x6E, 0x66, 0x69, 0x72,
		0x6D, 0x3D, 0x30, 0x0A, 0x78, 0x64, 0x5F, 0x64, 0x6A, 0x70,
		0x70, 0x3D, 0x30, 0x0A, 0x73, 0x6F, 0x6C, 0x69, 0x63, 0x69,
		0x74, 0x65, 0x64, 0x3D, 0x30, 0x0A, 0x00, 0x00
	};

	memcpy(bytes + 9 * 16, account.c_str(), account.size());
	memcpy(bytes + 10 * 16, password.c_str(), password.size());
	memcpy(bytes + 12 * 16, account.c_str(), account.size());
	memcpy(bytes + 16 * 16, name.c_str(), name.size());
	memcpy(bytes + 17 * 16 + 11, gddm.c_str(), gddm.size());
	memcpy(bytes + 19 * 16 + 7, account.c_str(), account.size());

	memcpy(bytes + 23 * 16 + 10, &market, 1);
	memcpy(bytes + 16 * 16 + 11, &market, 1);
	memcpy(bytes + 16 * 16 + 12, sid.c_str(), 6);
	memcpy(bytes + 17 * 16 + 3, &price, 4);
	memcpy(bytes + 17 * 16 + 7, &quant, 4);

	memcpy(bytes + 16 * 16 + 11, &market, 1);

	if (market == '1') {
		bytes[15 * 16 + 14] = 0x21;
	}
	else {
		bytes[15 * 16 + 14] = 0x11;
	}

	return std::string((char*)bytes, len);
}

static std::string get_market_price_buy_packet(const std::string& account, const std::string& password, const std::string& name, const std::string& gddm, char market, const std::string&sid, float price, int32_t quant, int price_type = 4)
{
	int len = 0x1D8;
	unsigned char bytes[] =
	{
		0xFD, 0xFF, 0x47, 0x99, 0x20, 0x00, 0x02, 0x01, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xCB, 0x65, 0xA9, 0x00,
		0x1E, 0x00, 0x00, 0x00, 0x36, 0x36, 0x36, 0x36, 0x30, 0x30,
		0x35, 0x30, 0x31, 0x32, 0x33, 0x34, 0x00, 0x00, 0x00, 0x00,
		0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x36, 0x36, 0x36, 0x36, 0x30, 0x30, 0x35, 0x30,
		0x31, 0x32, 0x33, 0x34, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x44,
		0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x21, 0x00, 0xB9, 0xCB, 0xC9, 0xFA,
		0xBB, 0xAA, 0x00, 0x2E, 0x35, 0x31, 0x00, 0x31, 0x33, 0x30,
		0x30, 0x30, 0x37, 0x32, 0x00, 0x00, 0x00, 0x80, 0xBF, 0xC8,
		0x00, 0x00, 0x00, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36,
		0x37, 0x38, 0x39, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};



	memcpy(bytes + 9 * 16, account.c_str(), account.size());
	memcpy(bytes + 10 * 16, password.c_str(), password.size());
	memcpy(bytes + 12 * 16, account.c_str(), account.size());
	memcpy(bytes + 16 * 16, name.c_str(), name.size());
	memcpy(bytes + 17 * 16 + 11, gddm.c_str(), gddm.size());

	memcpy(bytes + 16 * 16 + 11, &market, 1);
	memcpy(bytes + 16 * 16 + 12, sid.c_str(), 6);
	memcpy(bytes + 17 * 16 + 7, &quant, 4);

	if (market == '1') {
		bytes[15 * 16 + 14] = 0x21;
	}
	else {
		bytes[15 * 16 + 14] = 0x11;
	}

	std::ostringstream oss;

	oss << "ND=1.0\x0A";
	oss << "zjzh=" << account << "\x0A";
	oss << "interact=1\x0A";
	oss << "clientver=E065.18.51\x0A";
	oss << "sjwt=" << price_type << "\x0A";
	oss << "lxfs=\x0A";
	oss << "menuid=471\x0A";
	oss << "scdm=" << market << "\x0A";
	oss << "plwt=0\x0A";
	oss << "client=exe\x0A";
	oss << "type=sjwt\x0A";
	oss << "zxjg=" << price << "\x0A";
	oss << "name=\x0A";
	oss << "confirm=0\x0A";
	oss << "xd_djpp=0" << "\x0A";
	oss << "solicited=0" << "\x0A";


	std::string ret = std::string((char*)bytes, sizeof(bytes)) + oss.str();

	/*
	int append_size = (ret.size() + 15) / 16 * 16 - ret.size();
	ret.append(append_size, 0);
	*/

	return ret;
}


static std::string get_sell_stock_packet(const std::string& account, const std::string& password, const std::string& name, const std::string& gddm, char market, const std::string&sid, float price, int32_t quant)
{
	int len = 0x1c0;
	unsigned char bytes[] =
	{
		0xFD, 0xFF, 0x04, 0x55, 0x5B, 0x00, 0x03, 0x01, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0xDF, 0x9B, 0x00,
		0x0F, 0x00, 0x00, 0x00, 0x36, 0x36, 0x36, 0x36, 0x30, 0x30,
		0x35, 0x30, 0x31, 0x32, 0x33, 0x34, 0x00, 0x00, 0x00, 0x00,
		0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x36, 0x36, 0x36, 0x36, 0x30, 0x30, 0x35, 0x30,
		0x31, 0x32, 0x33, 0x34, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x44,
		0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x11, 0x00, 0xB9, 0xCB, 0xC9, 0xFA,
		0xBB, 0xAA, 0x00, 0x2E, 0x35, 0x31, 0x00, 0x32, 0x36, 0x30,
		0x30, 0x38, 0x31, 0x36, 0x00, 0xA4, 0x70, 0xC1, 0x41, 0xC8,
		0x00, 0x00, 0x00, 0x41, 0x33, 0x38, 0x31, 0x30, 0x35, 0x36,
		0x37, 0x39, 0x35, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4E,
		0x44, 0x3D, 0x31, 0x2E, 0x30, 0x0A, 0x7A, 0x6A, 0x7A, 0x68,
		0x3D, 0x36, 0x36, 0x36, 0x36, 0x30, 0x30, 0x35, 0x30, 0x31,
		0x32, 0x33, 0x34, 0x0A, 0x69, 0x6E, 0x74, 0x65, 0x72, 0x61,
		0x63, 0x74, 0x3D, 0x31, 0x0A, 0x63, 0x6C, 0x69, 0x65, 0x6E,
		0x74, 0x76, 0x65, 0x72, 0x3D, 0x45, 0x30, 0x36, 0x35, 0x2E,
		0x31, 0x38, 0x2E, 0x35, 0x31, 0x0A, 0x6C, 0x78, 0x66, 0x73,
		0x3D, 0x0A, 0x6D, 0x65, 0x6E, 0x75, 0x69, 0x64, 0x3D, 0x31,
		0x36, 0x32, 0x0A, 0x73, 0x63, 0x64, 0x6D, 0x3D, 0x32, 0x0A,
		0x70, 0x6C, 0x77, 0x74, 0x3D, 0x30, 0x0A, 0x63, 0x6C, 0x69,
		0x65, 0x6E, 0x74, 0x3D, 0x65, 0x78, 0x65, 0x0A, 0x74, 0x79,
		0x70, 0x65, 0x3D, 0x70, 0x74, 0x77, 0x74, 0x0A, 0x6E, 0x61,
		0x6D, 0x65, 0x3D, 0x0A, 0x63, 0x6F, 0x6E, 0x66, 0x69, 0x72,
		0x6D, 0x3D, 0x30, 0x0A, 0x78, 0x64, 0x5F, 0x64, 0x6A, 0x70,
		0x70, 0x3D, 0x30, 0x0A, 0x73, 0x6F, 0x6C, 0x69, 0x63, 0x69,
		0x74, 0x65, 0x64, 0x3D, 0x30, 0x0A, 0x00, 0x00
	};

	memcpy(bytes + 9 * 16, account.c_str(), account.size());
	memcpy(bytes + 10 * 16, password.c_str(), password.size());
	memcpy(bytes + 12 * 16, account.c_str(), account.size());
	memcpy(bytes + 16 * 16, name.c_str(), name.size());
	memcpy(bytes + 17 * 16 + 11, gddm.c_str(), gddm.size());
	memcpy(bytes + 19 * 16 + 7, account.c_str(), account.size());

	memcpy(bytes + 23 * 16 + 10, &market, 1);
	memcpy(bytes + 16 * 16 + 11, &market, 1);
	memcpy(bytes + 16 * 16 + 12, sid.c_str(), 6);
	memcpy(bytes + 17 * 16 + 3, &price, 4);
	memcpy(bytes + 17 * 16 + 7, &quant, 4);

	if (market == '1') {
		bytes[15 * 16 + 14] = 0x21;
	}
	else {
		bytes[15 * 16 + 14] = 0x11;
	}

	return std::string((char*)bytes, len);
}

static std::string get_market_price_sell_packet(const std::string& account, const std::string& password, const std::string& name, const std::string& gddm, char market, const std::string&sid, float price, int32_t quant, int price_type = 1)
{
	int len = 0x1D8;
	unsigned char bytes[] =
	{
		0xFD, 0xFF, 0xA5, 0xA0, 0x6B, 0x00, 0x03, 0x01, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xDA, 0x73, 0xA9, 0x00,
		0x10, 0x00, 0x00, 0x00, 0x36, 0x36, 0x36, 0x36, 0x30, 0x30,
		0x35, 0x30, 0x31, 0x32, 0x33, 0x34, 0x00, 0x00, 0x00, 0x00,
		0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x36, 0x36, 0x36, 0x36, 0x30, 0x30, 0x35, 0x30,
		0x31, 0x32, 0x33, 0x34, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x44,
		0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x11, 0x00, 0xB9, 0xCB, 0xC9, 0xFA,
		0xBB, 0xAA, 0x00, 0x2E, 0x35, 0x31, 0x00, 0x32, 0x36, 0x30,
		0x30, 0x38, 0x31, 0x36, 0x00, 0x00, 0x00, 0x80, 0xBF, 0xC8,
		0x00, 0x00, 0x00, 0x41, 0x33, 0x38, 0x31, 0x30, 0x35, 0x36,
		0x37, 0x39, 0x35, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};

	memcpy(bytes + 9 * 16, account.c_str(), account.size());
	memcpy(bytes + 10 * 16, password.c_str(), password.size());
	memcpy(bytes + 12 * 16, account.c_str(), account.size());
	memcpy(bytes + 16 * 16, name.c_str(), name.size());
	memcpy(bytes + 17 * 16 + 11, gddm.c_str(), gddm.size());

	memcpy(bytes + 16 * 16 + 11, &market, 1);
	memcpy(bytes + 16 * 16 + 12, sid.c_str(), 6);
	memcpy(bytes + 17 * 16 + 7, &quant, 4);

	if (market == '1') {
		bytes[15 * 16 + 14] = 0x21;
	}
	else {
		bytes[15 * 16 + 14] = 0x11;
	}

	std::ostringstream oss;

	oss << "ND=1.0\x0A";
	oss << "zjzh=" << account << "\x0A";
	oss << "interact=1\x0A";
	oss << "clientver=E065.18.51\x0A";
	oss << "sjwt=" << price_type << "\x0A";
	oss << "lxfs=\x0A";
	oss << "menuid=472\x0A";
	oss << "scdm=" << market << "\x0A";
	oss << "plwt=0\x0A";
	oss << "client=exe\x0A";
	oss << "type=sjwt\x0A";
	oss << "zxjg=" << price << "\x0A";
	oss << "name=\x0A";
	oss << "confirm=0\x0A";
	oss << "xd_djpp=0" << "\x0A";
	oss << "solicited=0" << "\x0A";


	std::string ret = std::string((char*)bytes, sizeof(bytes)) + oss.str();

	/*
	int append_size = (ret.size() + 15) / 16 * 16 - ret.size();
	ret.append(append_size, 0);
	*/

	return ret;
}

static std::string get_date_string()
{
	time_t rawtime;
	struct tm * timeinfo;
	char buffer[80] = { 0 };

	time(&rawtime);
	timeinfo = localtime(&rawtime);

	strftime(buffer, 80, "%Y%m%d", timeinfo);

	return std::string(buffer);
}


static std::string get_cancel_packet(const std::string& account, const std::string& password, const std::string& name, const std::string& gddm, char market, const std::string&sid, const std::string& htbh)
{
	int len = 0x1c0;
	unsigned char bytes[] =
	{
		0xFD, 0xFF, 0x04, 0x55, 0x5B, 0x00, 0x04, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0xF3, 0x9B, 0x00,
		0x33, 0x00, 0x00, 0x00, 0x36, 0x36, 0x36, 0x36, 0x30, 0x30,
		0x35, 0x30, 0x31, 0x32, 0x33, 0x34, 0x00, 0x00, 0x00, 0x00,
		0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x41, 0x33, 0x38, 0x31,
		0x30, 0x35, 0x36, 0x37, 0x39, 0x35, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x36, 0x36, 0x36, 0x36, 0x30, 0x30, 0x35, 0x30,
		0x31, 0x32, 0x33, 0x34, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x44,
		0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x33, 0x00, 0xB9, 0xCB, 0xC9, 0xFA,
		0xBB, 0xAA, 0x00, 0x2E, 0x35, 0x31, 0x00, 0x32, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB6,
		0x76, 0x97, 0xA5, 0x37, 0x37, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};

	memcpy(bytes + 9 * 16, account.c_str(), account.size());
	memcpy(bytes + 10 * 16, password.c_str(), password.size());
	memcpy(bytes + 11 * 16, gddm.c_str(), gddm.size());
	memcpy(bytes + 12 * 16, account.c_str(), account.size());

	memcpy(bytes + 16 * 16, name.c_str(), name.size());
	memcpy(bytes + 17 * 16 + 11, htbh.c_str(), htbh.size());

	std::ostringstream oss;

	oss << "ND=1.0\x0A";
	oss << "zjzh=" << account << "\x0A";
	oss << "zqdm=" << sid << "\x0A";
	oss << "htbh=" << htbh << "\x0A";
	oss << "clientver=E065.18.51\x0A";
	oss << "wtph=\x0A";
	oss << "menuid=168\x0A";
	oss << "scdm=" << market << "\x0A";
	oss << "client=exe\x0A";
	oss << "cjbh=\x0A";
	oss << "gdzh=" << gddm << "\x0A";
	oss << "cxsl=\x0A";
	oss << "date=" << get_date_string() << "\x0A";


	std::string ret = std::string((char*)bytes, sizeof(bytes)) + oss.str();

	/*
	int append_size = (ret.size() + 15) / 16 * 16 - ret.size();
	ret.append(append_size, 0);
	*/
	return ret;
}

static std::string get_query_all_contract_packet(const std::string& account, const std::string& password, const std::string& gddm, char market)
{
	int len = 0x180;
	unsigned char bytes[] =
	{
		0xFD, 0xFF, 0x05, 0xBB, 0x4D, 0x00, 0x03, 0x06, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x96, 0xE7, 0xAA, 0x00,
		0x3B, 0x00, 0x00, 0x00, 0x36, 0x36, 0x36, 0x36, 0x30, 0x30,
		0x35, 0x30, 0x31, 0x32, 0x33, 0x34, 0x00, 0x00, 0x00, 0x00,
		0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x36, 0x36, 0x36, 0x36, 0x30, 0x30, 0x35, 0x30,
		0x31, 0x32, 0x33, 0x34, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x44,
		0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36,
		0x37, 0x38, 0x39, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4E,
		0x44, 0x3D, 0x31, 0x2E, 0x30, 0x0A, 0x7A, 0x6A, 0x7A, 0x68,
		0x3D, 0x36, 0x36, 0x36, 0x36, 0x30, 0x30, 0x35, 0x30, 0x34,
		0x34, 0x33, 0x33, 0x0A, 0x63, 0x6C, 0x69, 0x65, 0x6E, 0x74,
		0x76, 0x65, 0x72, 0x3D, 0x45, 0x30, 0x36, 0x35, 0x2E, 0x31,
		0x38, 0x2E, 0x35, 0x31, 0x0A, 0x6D, 0x65, 0x6E, 0x75, 0x69,
		0x64, 0x3D, 0x31, 0x36, 0x38, 0x0A, 0x73, 0x63, 0x64, 0x6D,
		0x3D, 0x31, 0x0A, 0x63, 0x6C, 0x69, 0x65, 0x6E, 0x74, 0x3D,
		0x65, 0x78, 0x65, 0x0A, 0x7A, 0x63, 0x73, 0x78, 0x3D, 0x31,
		0x0A, 0x00, 0x00, 0x00
	};

	memcpy(bytes + 9 * 16, account.c_str(), account.size());
	memcpy(bytes + 10 * 16, password.c_str(), password.size());
	memcpy(bytes + 12 * 16, account.c_str(), account.size());

	memcpy(bytes + 17 * 16 + 11, gddm.c_str(), gddm.size());
	memcpy(bytes + 19 * 16 + 7, account.c_str(), account.size());
	memcpy(bytes + 22 * 16 + 9, &market, 1);

	return std::string((char*)bytes, len);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

static std::vector<internal_order_item> parse_query_oder_response(const std::string& resp, bool& success)
{
	std::vector<internal_order_item> ret;

	uint16_t resp_code;
	memcpy(&resp_code, resp.c_str()+16 * 9, 2);

	if (resp_code != 0) {
		success = false;
		std::string msg(resp.c_str() + 16 * 9 + 2);
		return ret;
	}
	else {
		success = true;
	}

	const char *hd_start = resp.c_str() + 20 * 16 + 1;
	uint32_t total_bytes = 0;
	memcpy(&total_bytes, hd_start - 4, 4);

	uint16_t item_count = 0;
	memcpy(&item_count, hd_start + 6, 2);

	uint16_t item_bytes = 0;
	memcpy(&item_bytes, hd_start + 0xc, 2);

	const char *item_start = hd_start + total_bytes - item_count * item_bytes;

	for (int i = 0; i < item_count; ++i) {
		internal_order_item oi;
		const char *cur_item_start = item_start + i * item_bytes;

		uint32_t order_num = 0;

		memcpy(&order_num, cur_item_start + 15 * 4, 4);

		std::ostringstream oss;
		oss << order_num;
		oi.order_id = oss.str();
		oi.sid.assign(cur_item_start + 4, 6);
		oi.sname.assign(cur_item_start + 10, 8);
		oi.operation.assign(cur_item_start + 18, 4);
		if (oi.operation == "Âô³ö" || oi.operation == "³·Âô") {
			oi.operation = "sell";
		}
		else if (oi.operation == "ÂòÈë" || oi.operation == "³·Âò") {
			oi.operation = "buy";
		}

		oi.time.assign(cur_item_start + 40, 8);
		oi.state.assign(cur_item_start + 5 * 16, 4);

		std::string deal_price(cur_item_start + 13 * 4, 8);

		std::istringstream iss(deal_price);
		iss >> oi.deal_price;

		uint32_t day = 0;
		memcpy(&day, cur_item_start, 4);

		std::ostringstream oss_day;
		oss_day << day;
		oi.day = oss_day.str();
		oi.day = oi.day.substr(0, 4) + "-" + oi.day.substr(4, 2) + "-" + oi.day.substr(6, 2);

		memcpy(&oi.quant, cur_item_start + 36, 4);
		memcpy(&oi.deal_quant, cur_item_start + 48, 4);
		memcpy(&oi.price, cur_item_start + 28, 8);

		ret.push_back(oi);
	}

	return ret;
}

static std::string parse_place_order_response(const std::string& resp, std::string& msg, uint32_t& packet_index)
{
	std::string ret;

	uint16_t code = *(uint16_t*)(resp.c_str() + 9 * 16);
	memcpy(&packet_index, resp.c_str()+ 0x8c, 4);

	if (code == 0) {
		ret.assign(resp.c_str() + 19 * 16 + 13);
		msg.assign(resp.c_str() + 9 * 16 + 2);
	}
	else {
		msg.assign(resp.c_str() + 9 * 16 + 2);
	}

	return ret;
}


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

int hexin_stock_broker::try_recv_packet(std::string& pkt)
{
	pkt = recv_response_and_decrypt(m_socket, m_encrypt_key1, m_encrypt_key2);

	return pkt.size();
}

hexin_stock_broker::hexin_stock_broker(const std::vector<boost::tuple<std::string, uint16_t>> &server_vec, const std::string& account, const std::string& password1, const std::string& password2, bool wait_response)
	:
	m_server_vec(server_vec),
	m_account(account),
	m_password(password1),
	m_comm_password(password2),
	m_wait_response(wait_response),
	m_login(false)
{
	if (m_account.size() < 12) {
		m_account.resize(12, 0);
	}
}

hexin_stock_broker::~hexin_stock_broker()
{

}

std::string hexin_stock_broker::get_account()
{
	ScopedLock lck(m_critical_sec);

	return m_account;
}

int hexin_stock_broker::login()
{
	m_login = false;
	try {

		boost::tuple<std::string, uint16_t> server_tuple = DetectBestServer(m_server_vec);
		m_server = server_tuple.get<0>();
		m_port = server_tuple.get<1>();

		m_socket.connect(m_server, m_port);

		uint8_t key1_out_buff[24] = { 0 };
		gen_key1(key1_out_buff, (uint8_t*)m_account.c_str());
		m_encrypt_key1.assign((char*)key1_out_buff, 24);

		m_last_msg = "send first packet";

		std::string first_packet = gen_first_packet(m_account);
		m_socket.send(first_packet.c_str(), first_packet.size());
		std::cout << "first step" << endl;
		std::string first_ret = recv_response(m_socket);



		m_last_msg = "send second packet";
		std::string second_packet = gen_second_packet(m_account);
		m_socket.send(second_packet.c_str(), second_packet.size());
		std::cout << "second step" << endl;


		std::string ret_str = recv_response_and_unzip(m_socket);

		memcpy(m_session_id, ret_str.c_str() + 2, 4);

		uint16_t len_4_hash = *(uint16_t*)(ret_str.c_str() + 0x13d);

		MD5 md5(m_comm_password);
		//std::string str_ret = md5.toStr();
		//md5.getDigest

		const char* digest_ptr = (const char*)md5.getDigest();

		m_decrypt_key1.assign(digest_ptr, 8);
		m_decrypt_key2.assign(digest_ptr + 8, 8);

		memcpy(m_decrypt_out_buff, ret_str.c_str() + 0x13f, 0x5a0);

		int32_t src_len = 0x5a0;
		server_en_de_crypt(m_decrypt_out_buff, m_decrypt_out_buff, &src_len, (uint8_t*)m_decrypt_key1.c_str(), (uint8_t*)m_decrypt_key2.c_str(), 1);

		if (m_decrypt_out_buff[16 * 9] != 0 || m_decrypt_out_buff[16 * 9 + 1] != 0) {
			m_last_msg = "commication password error";
			return -1;
		}

		uint8_t origin_md5[16] = { 0 };
		memcpy(origin_md5, m_decrypt_out_buff, 16);

		memcpy(m_decrypt_out_buff, m_decrypt_out_buff + 16, 0x590);

		MD5 md5_of_decrypt(std::string((char*)m_decrypt_out_buff, 0x590));
		const char* current_md5 = (const char*)md5_of_decrypt.getDigest();

		uint8_t key2_out_buff[16] = { 0 };
		int32_t key2_out_len = 0;

		gen_key2((unsigned char*)ret_str.c_str() + 0x8E1, len_4_hash, key2_out_buff, &key2_out_len, m_decrypt_out_buff);
		m_encrypt_key2.assign((char*)key2_out_buff, key2_out_len);


		//now login
		m_last_msg = "send login request";
		std::cout << "send login request" << endl;
		int ret = send_login_packet();

		std::string resp = recv_response_and_decrypt(m_socket, m_encrypt_key1, m_encrypt_key2);

		while (resp.size() == 4) {
			resp = recv_response_and_decrypt(m_socket, m_encrypt_key1, m_encrypt_key2);
		}
		uint16_t retcode = *(uint16_t*)(resp.c_str() + 9 * 16);
		if (retcode != 0) {
			m_last_msg.assign(resp.c_str() + 9 * 16 + 2);
			return -1;
		}

		m_account_name = resp.c_str() + 0x132;
		m_account_name.resize(6, 0);

		m_last_msg = "query gddm";
		std::cout << "query gddm" << endl;
		//query gddm, pkt3
		ret = send_get_gddm_packet();

		resp = recv_response_and_decrypt(m_socket, m_encrypt_key1, m_encrypt_key2);

		while (resp.size() == 4) {
			resp = recv_response_and_decrypt(m_socket, m_encrypt_key1, m_encrypt_key2);
		}

		//get gddm list
		int start_pos = 0;
		int pos = resp.find("SHA", start_pos);
		while (pos != -1) {
			m_sh_gddm_list.push_back(resp.substr(pos - 11 - 10, 10));
			start_pos = pos + 3;
			pos = resp.find("SHA", start_pos);
		}

		start_pos = 0;
		pos = resp.find("SZA", start_pos);
		while (pos != -1) {
			m_sz_gddm_list.push_back(resp.substr(pos - 11 - 10, 10));
			start_pos = pos + 3;
			pos = resp.find("SZA", start_pos);
		}

		if (m_sz_gddm_list.size() == 0 || m_sh_gddm_list.size() == 0) {
			m_last_msg = "query gddm failed";
			return -1;
		}

		ret = send_get_account_holding();
		resp = recv_response_and_decrypt(m_socket, m_encrypt_key1, m_encrypt_key2);
		while (resp.size() == 4 || resp[6] != 0x01 || resp[7] != '\x86') {
			resp = recv_response_and_decrypt(m_socket, m_encrypt_key1, m_encrypt_key2);
		}
		ret = handle_get_holding_response(resp);

		ret = send_get_account_balance();
		resp = recv_response_and_decrypt(m_socket, m_encrypt_key1, m_encrypt_key2);

		//while (resp.size() == 4) {
		while (resp.size() == 4 || resp[6] != 0x22 || resp[7] != '\x86') {
			resp = recv_response_and_decrypt(m_socket, m_encrypt_key1, m_encrypt_key2);
		}
		ret = handle_get_balance_response(resp);

		ret = send_get_account_all_order();
		resp = recv_response_and_decrypt(m_socket, m_encrypt_key1, m_encrypt_key2);
		while (resp.size() == 4 || resp[6] != 0x03 || resp[7] != '\x86') {
			resp = recv_response_and_decrypt(m_socket, m_encrypt_key1, m_encrypt_key2);
		}
		ret = handle_all_order_response(resp);

		m_last_msg = "login success";
		cout << m_last_msg << endl;

		m_login = true;

		return 0;
	}
	catch(std::exception& e)
	{
		m_last_msg = e.what();
		return -1;
	}
	catch (...) {
		return -1;
	}
}

void hexin_stock_broker::logout()
{
	m_login = false;

	m_socket.close();

	ScopedLock lck(m_critical_sec);

	std::map<std::string, order_state>::iterator iter;
	for (iter = m_pending_order_map.begin(); iter != m_pending_order_map.end(); ) {
		if (iter->second.state == "waiting") {
			iter->second.state = "failed";
			m_completed_order_map[iter->second.user_order_id] = iter->second;
			iter = m_pending_order_map.erase(iter);
		}
		else {
			++iter;
		}
	}
}

std::string hexin_stock_broker::create_order(const std::string& operation, const std::string& direction, const std::string& sid, double price, int amount)
{
	order_state ostate;
	ostate.operation = operation;

	ostate.direction = direction;
	ostate.state = "waiting";
	ostate.sid = sid;
	ostate.price = price;
	ostate.quant = amount;
	ostate.user_order_id = gen_uuid();
	ostate.packet_id = m_packet_index;
	ostate.time = currentDateTime();

	ScopedLock lck(m_critical_sec);

	m_pending_order_map[ostate.user_order_id] = ostate;

	return ostate.user_order_id;
}

void hexin_stock_broker::buy(const std::string& sid, double price, int quant, const std::string& price_type, const std::string& user_order_id)
{
	bool found = false;
	do {
		ScopedLock lck(m_critical_sec);
		std::map<std::string, order_state>::iterator iter = m_pending_order_map.find(user_order_id);

		if (iter != m_pending_order_map.end()) {
			iter->second.packet_id = m_packet_index;
			if (iter->second.state == "waiting") {
				iter->second.state = "sending";
				found = true;
			}
		}
	} while (0);

	if (found) {
		send_buy(sid, price, quant, price_type);

		if (m_wait_response) {
			std::string resp = recv_response_and_decrypt(m_socket, m_encrypt_key1, m_encrypt_key2);

			while (resp.size() == 4 || resp[6] != 0x02 || resp[7] != '\x81') {
				resp = recv_response_and_decrypt(m_socket, m_encrypt_key1, m_encrypt_key2);
			}

			handle_buy_response(resp);
		}
	}
}

int hexin_stock_broker::handle_buy_response(const std::string& resp)
{
	std::string msg;
	uint32_t packet_index;

	std::string orderid = parse_place_order_response(resp, msg, packet_index);

	std::string internal_order_id;
	std::string sid;

	do {
		ScopedLock lck(m_critical_sec);
		std::map<std::string, order_state>::iterator iter = m_pending_order_map.begin();
		for (; iter != m_pending_order_map.end(); ++iter) {
			if (iter->second.packet_id == packet_index) {
				if (orderid.size() > 0) {
					iter->second.internal_order_id = orderid;
					if (iter->second.state == "sending") {
						iter->second.state = "pending";
						return 0;
					}
					else if (iter->second.state == "canceling") {

						internal_order_id = orderid;
						sid = iter->second.sid;
					}
				}
				else {
					iter->second.state = "failed";
					iter->second.desc = msg;
					m_completed_order_map[iter->second.user_order_id] = iter->second;
					m_pending_order_map.erase(iter->second.user_order_id);
					
				}
				break;
			}
		}
	} while (0);

	if (internal_order_id.size() > 0) {
		int ret = send_cancel(internal_order_id, sid);
	}

	return 0;
}

void hexin_stock_broker::sell(const std::string& sid, double price, int quant, const std::string& price_type, const std::string& user_order_id)
{
	bool found = false;
	do {
		ScopedLock lck(m_critical_sec);
		std::map<std::string, order_state>::iterator iter = m_pending_order_map.find(user_order_id);

		if (iter != m_pending_order_map.end()) {
			iter->second.packet_id = m_packet_index;
			if (iter->second.state == "waiting") {
				iter->second.state = "sending";
				found = true;
			}
		}
	} while (0);

	if (found) {
		send_sell(sid, price, quant, price_type);

		if (m_wait_response) {
			std::string resp = recv_response_and_decrypt(m_socket, m_encrypt_key1, m_encrypt_key2);

			while (resp.size() == 4 || resp[6] != 0x03 || resp[7] != '\x81') {
				resp = recv_response_and_decrypt(m_socket, m_encrypt_key1, m_encrypt_key2);
			}
			handle_sell_response(resp);
		}
	}

}

order_state hexin_stock_broker::get_order_state(const std::string& user_order_id)
{
	ScopedLock lck(m_critical_sec);

	if (m_pending_order_map.find(user_order_id) != m_pending_order_map.end()) {
		return m_pending_order_map[user_order_id];
	}

	if (m_completed_order_map.find(user_order_id) != m_completed_order_map.end()) {
		return m_completed_order_map[user_order_id];
	}

	return order_state();
}

int hexin_stock_broker::handle_sell_response(const std::string& resp)
{
	std::string msg;
	uint32_t packet_index;

	std::string orderid = parse_place_order_response(resp, msg, packet_index);

	std::string internal_order_id;
	std::string sid;

	do {
		ScopedLock lck(m_critical_sec);
		std::map<std::string, order_state>::iterator iter = m_pending_order_map.begin();
		for (; iter != m_pending_order_map.end(); ++iter) {
			if (iter->second.packet_id == packet_index) {
				if (orderid.size() > 0) {
					iter->second.internal_order_id = orderid;
					if (iter->second.state == "sending") {
						iter->second.state = "pending";
						return 0;
					}
					else if (iter->second.state == "canceling") {

						internal_order_id = orderid;
						sid = iter->second.sid;
					}
				}
				else {
					iter->second.state = "failed";
					iter->second.desc = msg;
					m_completed_order_map[iter->second.user_order_id] = iter->second;
					m_pending_order_map.erase(iter->second.user_order_id);
				}
				break;
			}
		}
	} while (0);

	if (internal_order_id.size() > 0) {
		int ret = send_cancel(internal_order_id, sid);
		if (m_wait_response) {
			std::string resp = recv_response_and_decrypt(m_socket, m_encrypt_key1, m_encrypt_key2);
			while (resp.size() == 4 || resp[6] != 0x04 || resp[7] != '\x80') {
				resp = recv_response_and_decrypt(m_socket, m_encrypt_key1, m_encrypt_key2);
			}
			handle_cancel_response(resp);
		}
	}

	return 0;
}

/*
order_item hexin_stock_broker::get_order_state(const std::string& order_id)
{

}
*/

void hexin_stock_broker::cancel_order(const std::string& user_order_id)
{
	std::string internal_order_id;
	std::string sid;
	do {
		ScopedLock lck(m_critical_sec);

		std::map<std::string, order_state>::iterator iter = m_pending_order_map.find(user_order_id);
		if (iter != m_pending_order_map.end()) {
			internal_order_id = iter->second.internal_order_id;
			sid = iter->second.sid;

			if (iter->second.state == "waiting") {
				iter->second.state = "canceled";
				m_completed_order_map[iter->second.user_order_id] = iter->second;
				m_pending_order_map.erase(iter->second.user_order_id);
			}
			else {
				iter->second.state = "canceling";
			}
		}
		else if (m_completed_order_map.find(user_order_id) != m_completed_order_map.end()) {
			//
			return;
		}
		else {
			cout << "order " << user_order_id << " not found in record" << endl;
			return;
		}

	} while (0);

	if (internal_order_id != "") {
		send_cancel(internal_order_id, sid);

		if (m_wait_response) {
			std::string resp = recv_response_and_decrypt(m_socket, m_encrypt_key1, m_encrypt_key2);
			while (resp.size() == 4 || resp[6] != 0x04 || resp[7] != '\x80') {
				resp = recv_response_and_decrypt(m_socket, m_encrypt_key1, m_encrypt_key2);
			}
			handle_cancel_response(resp);
		}
	}
}

int hexin_stock_broker::handle_cancel_response(const std::string& resp)
{
	std::string msg;
	uint32_t packet_index = 0;

	std::string internal_order_id;
	uint16_t code = *(uint16_t*)(resp.c_str() + 9 * 16);
	memcpy(&packet_index, resp.c_str() + 0x8c, 4);

	msg.assign(resp.c_str() + 9 * 16 + 2);
	internal_order_id.assign(resp.c_str() + 11 * 16 + 6);

	ScopedLock lck(m_critical_sec);

	std::map<std::string, order_state>::iterator iter;
	for (iter = m_pending_order_map.begin(); iter != m_pending_order_map.end(); ++iter) {
		if (iter->second.internal_order_id == internal_order_id) {
			if (code == 0) {
				iter->second.state = "canceled";
				m_completed_order_map[iter->second.user_order_id] = iter->second;
				m_pending_order_map.erase(iter->second.user_order_id);
			}
			else {
				iter->second.desc = "cancel failed";
				cout << "cancel " << internal_order_id << " failed" << endl;
			}
			break;
		}
	}

	return 0;
}

int hexin_stock_broker::handle_deal_notification(const std::string& resp)
{	
	int erased_size = 20 * 16 + 1;

	std::string text_response(resp.c_str() + erased_size, resp.size() - erased_size);

	std::vector<std::string> line_vec;
	SplitString(text_response, std::back_inserter(line_vec));

	std::map<std::string, std::string> key_value_map;

	for (int i = 0; i < line_vec.size(); ++i) {
		std::vector<std::string> key_value;
		SplitString(line_vec[i], std::back_inserter(key_value), std::string("="));

		if (key_value.size() == 2) {
			if (key_value[0] == "extend") {
				std::vector<std::string> inner_lines;
				SplitString(key_value[1], std::back_inserter(inner_lines), std::string("|"));

				for (int j = 0; j < inner_lines.size(); ++j) {
					std::vector<std::string> inner_key_value;
					SplitString(inner_lines[j], std::back_inserter(inner_key_value), std::string("*"));

					if (inner_key_value.size() == 2) {
						key_value_map[inner_key_value[0]] = inner_key_value[1];
					}
				}
			}
			else {
				key_value_map[key_value[0]] = key_value[1];
			}
		}
	}

	std::string sid = key_value_map["zqdm"];
	int deal_quant = atoi(key_value_map["cjsl"].c_str());
	double deal_price = atof(key_value_map["cjjg"].c_str());

	std::string internal_order_id = key_value_map["sbbh"];
	internal_order_id = internal_order_id.substr(internal_order_id.size()-6,6);

	int order_id_int = atoi(internal_order_id.c_str());
	ostringstream oss;
	oss << order_id_int;

	internal_order_id = oss.str();

	ScopedLock lck(m_critical_sec);

	std::map<std::string, order_state>::iterator iter;
	bool found = false;
	for (iter = m_pending_order_map.begin(); iter != m_pending_order_map.end(); ++iter) {
		if (iter->second.internal_order_id == internal_order_id) {
			
			//double cur_deal_price = iter->second.deal_quant*iter->second.deal_price + deal_price*deal_quant

			iter->second.deal_price = deal_price;
			iter->second.deal_quant = deal_quant;

			if (iter->second.deal_quant == iter->second.quant) {
				iter->second.state = "fulfilled";

				m_completed_order_map[iter->second.user_order_id] = iter->second;
				m_pending_order_map.erase(iter);
			}
			else {
				if (iter->second.deal_quant > 0) {
					iter->second.state = "partfilled";
				}
			}
			found = true;
			break;
		}
	}

	if (!found) {
		cout << "deal notification internal order id " << internal_order_id << " not found" << endl;
	}

	return 0;
}

std::vector<order_state> hexin_stock_broker::get_all_order()
{
	ScopedLock lck(m_critical_sec);

	std::vector<order_state> order_vec;

	std::map<std::string, order_state>::iterator iter;
	for (iter = m_pending_order_map.begin(); iter != m_pending_order_map.end(); ++iter) {
		order_vec.push_back(iter->second);
	}
	for (iter = m_completed_order_map.begin(); iter != m_completed_order_map.end(); ++iter) {
		order_vec.push_back(iter->second);
	}

	return order_vec;
}

int hexin_stock_broker::handle_all_order_response(const std::string& resp)
{
	bool success;
	 std::vector<internal_order_item> orders = parse_query_oder_response(resp, success);

	 if (!success) {
		 return 0;
	 }

	 ScopedLock lck(m_critical_sec);
	 m_all_internal_order = orders;

	 for (int i = 0; i < orders.size(); ++i) {
		 std::map<std::string, order_state>::iterator iter;
		 bool found = false;
		 for (iter = m_pending_order_map.begin(); iter != m_pending_order_map.end(); ++iter) {
			 if (iter->second.internal_order_id == orders[i].order_id) {
				 iter->second.deal_quant = orders[i].deal_quant;
				 iter->second.deal_price = orders[i].deal_price;
				 iter->second.desc = orders[i].state;
				 if (orders[i].deal_quant == orders[i].quant) {
					 iter->second.state = "fulfilled";

					 m_completed_order_map[iter->second.user_order_id] = iter->second;
					 m_pending_order_map.erase(iter);
				 }
				 else {
					 if (orders[i].deal_quant > 0) {
						 iter->second.state = "partfilled";
					 }
				 }
				 found = true;
				 break;
			 }
		 }

		 if (!found) {
			 order_state os;
			 os.quant = orders[i].quant;
			 os.deal_quant = orders[i].deal_quant;
			 os.internal_order_id = orders[i].order_id;
			 os.sid = orders[i].sid;
			 os.price = orders[i].price;
			 os.time = orders[i].day + " " + orders[i].time;
			 os.deal_price = orders[i].deal_price;
			 os.operation = orders[i].operation;
			 os.desc = orders[i].state;

			 std::string user_order_id = gen_uuid();
			 os.user_order_id = user_order_id;

			 if (os.operation == "buy") {
				 os.direction = "open";
			 }
			 else {
				 os.direction = "close";
			 }

			 if (orders[i].deal_quant == orders[i].quant) {
				 os.state = "fulfilled";

				 m_completed_order_map[user_order_id] = os;
			 }
			 else {
				 if (orders[i].deal_quant > 0) {
					 os.state = "partfilled";
					 m_pending_order_map[user_order_id] = os;
				 }
				 else {
					 if (orders[i].state == "ÒÑ³·") {
						 os.state = "canceled";
						 m_completed_order_map[user_order_id] = os;
					 }
					 else {
						 os.state = "pending";
						 m_pending_order_map[user_order_id] = os;
					 }
				 }
			 }
		 }
	 }

	 return 0;
}

std::vector<holding_item> hexin_stock_broker::get_holding_stock()
{
	ScopedLock lck(m_critical_sec);
	
	return m_holding_stock;
}

int hexin_stock_broker::handle_get_holding_response(const std::string& resp)
{
	std::vector<holding_item> holding_stock;

	uint16_t resp_code;
	memcpy(&resp_code, resp.c_str() + 16 * 9, 2);

	if (resp_code != 0) {
		std::string msg(resp.c_str() + 16 * 9 + 2);
		return 0;
	}

	const char *hd_start = resp.c_str() + 20 * 16 + 1;
	uint32_t total_bytes = 0;
	memcpy(&total_bytes, hd_start - 4, 4);

	uint16_t holding_count = 0;
	memcpy(&holding_count, hd_start + 6, 2);

	uint16_t item_bytes = 0;
	memcpy(&item_bytes, hd_start + 0xc, 2);

	const char *holding_start = hd_start + total_bytes - holding_count * item_bytes;

	for (int i = 0; i < holding_count; ++i) {
		holding_item hi;
		hi.sid.assign(holding_start + i * item_bytes + 0, 6);
		hi.sname.assign(holding_start + i * item_bytes + 6, 8);

		memcpy(&hi.quant, holding_start + i * item_bytes + 14, 8);
		memcpy(&hi.quant_available, holding_start + i * item_bytes + 22, 8);
		memcpy(&hi.buy_price, holding_start + i * item_bytes + 46, 8);

		holding_stock.push_back(hi);
	}

	ScopedLock lck(m_critical_sec);

	m_holding_stock = holding_stock;

	return 0;
}

std::vector<double> hexin_stock_broker::get_money_left()
{
	std::vector<double> balance_vec;
	ScopedLock lck(m_critical_sec);

	balance_vec.push_back(0);

	if (m_balance.size() > 0) {
		balance_vec.push_back(m_balance[0]);
	}
	else {
		balance_vec.push_back(0);
	}

	return balance_vec;
}

int hexin_stock_broker::handle_get_balance_response(const std::string& resp)
{
	double db1, db2, db3, db4;

	memcpy(&db1, resp.c_str() + 23 * 16 + 2, 8);
	memcpy(&db2, resp.c_str() + 23 * 16 + 10, 8);
	memcpy(&db3, resp.c_str() + 24 * 16 + 10, 8);
	memcpy(&db4, resp.c_str() + 26 * 16 + 2, 8);

	/*
	double db5, db6, db7, db8;
	memcpy(&db5, resp.c_str() + 22 * 16 + 2, 8);
	memcpy(&db5, resp.c_str() + 22 * 16 + 10, 8);
	*/

	std::vector<double> balance;
	balance.push_back(db1);
	balance.push_back(db2);
	balance.push_back(db3);
	balance.push_back(db4);

	ScopedLock lck(m_critical_sec);

	m_balance = balance;

	return 0;
}

int hexin_stock_broker::handle_packet(const std::string& pkt)
{
	if (pkt.size() == 4) {
		return 0;
	}

	int ret = 0;

	cout << "packet " << (unsigned int)(unsigned char)pkt[6] << " " << (unsigned int)(unsigned char)pkt[7]<< endl;

	if (pkt[6] == '\x02' && pkt[7] == '\x81') {
		//buy
		ret = handle_buy_response(pkt);
	}
	else if (pkt[6] == '\x03' && pkt[7] == '\x81') {
		//sell
		ret = handle_sell_response(pkt);
	}
	else if (pkt[6] == '\x03' && pkt[7] == '\x86') {
		//all order
		ret = handle_all_order_response(pkt);
	}
	else if (pkt[6] == '\x01' && pkt[7] == '\x86') {
		//all holding
		ret = handle_get_holding_response(pkt);
	}
	else if (pkt[6] == '\x22' && pkt[7] == '\x86') {
		//account balance
		ret = handle_get_balance_response(pkt);
	}
	else if (pkt[6] == '\x04' && pkt[7] == '\x80') {
		//cancel resp
		ret = handle_cancel_response(pkt);
	}
	else if (pkt[6] == 0 && pkt[7] == '\x89')
	{
		//ret = handle_deal_notification(pkt); not used currently
	}
	else {
		cout << "unknown packet " << pkt[6] << " " << pkt[7] << endl;
	}

	return 0;
}

int hexin_stock_broker::update_account()
{
	//cout << "update account " << endl;
	if (!m_login) {
		return 0;
	}

	int ret = 0;
	std::string resp;

	//cout << "send get balance" << endl;

	send_get_account_balance();
	if (m_wait_response) {
		resp = recv_response_and_decrypt(m_socket, m_encrypt_key1, m_encrypt_key2);
		while (resp.size() == 4 || resp[6] != 0x22 || resp[7] != '\x86') {
			resp = recv_response_and_decrypt(m_socket, m_encrypt_key1, m_encrypt_key2);
		}
		ret = handle_get_balance_response(resp);
	}

	bool send = false;

	do {
		ScopedLock lck(m_critical_sec);
		if (m_pending_order_map.size() > 0) {
			send = true;
		}
	} while (0);

	if (send) {
		send_get_account_all_order();
		if (m_wait_response) {
			resp = recv_response_and_decrypt(m_socket, m_encrypt_key1, m_encrypt_key2);
			while (resp.size() == 4 || resp[6] != 0x03 || resp[7] != '\x86') {
				resp = recv_response_and_decrypt(m_socket, m_encrypt_key1, m_encrypt_key2);
			}
			ret = handle_all_order_response(resp);
		}

		send_get_account_holding();
		if (m_wait_response) {
			resp = recv_response_and_decrypt(m_socket, m_encrypt_key1, m_encrypt_key2);
			while (resp.size() == 4 || resp[6] != 0x01 || resp[7] != '\x86') {
				resp = recv_response_and_decrypt(m_socket, m_encrypt_key1, m_encrypt_key2);
			}
			ret = handle_get_holding_response(resp);
		}
	}

	return 0;
}


int hexin_stock_broker::send_login_packet()
{
	std::string login_pkt = get_login_packet(m_account, m_password);
	std::string encrypt_login_pkt = encrypt_packet(login_pkt.c_str(), login_pkt.size(), m_session_id, m_packet_index, m_encrypt_key1, m_encrypt_key2, m_decrypt_out_buff);
	std::string head = get_packet_head(encrypt_login_pkt.size());

	std::string whole_pkt = head + encrypt_login_pkt;

	m_socket.send(whole_pkt.c_str(), whole_pkt.size());

	return 0;
}

int hexin_stock_broker::send_get_gddm_packet()
{
	//query gddm, pkt3
	std::string pkt3 = get_query_gddm_packet(m_account, m_password, m_account_name);
	std::string encrypt_pkt_3 = encrypt_packet(pkt3.c_str(), pkt3.size(), m_session_id, m_packet_index, m_encrypt_key1, m_encrypt_key2, m_decrypt_out_buff);
	std::string head = get_packet_head(encrypt_pkt_3.size());

	std::string whole_pkt = head + encrypt_pkt_3;

	m_socket.send(whole_pkt.c_str(), whole_pkt.size());

	return 0;
}

int hexin_stock_broker::send_get_account_holding()
{
	std::string pkt5 = get_account_holding_packet(m_account, m_password, m_account_name, m_sh_gddm_list[0]);
	std::string encrypt_pkt_5 = encrypt_packet(pkt5.c_str(), pkt5.size(), m_session_id, m_packet_index, m_encrypt_key1, m_encrypt_key2, m_decrypt_out_buff);

	std::string head = get_packet_head(encrypt_pkt_5.size());

	std::string whole_pkt = head + encrypt_pkt_5;

	m_socket.send(whole_pkt.c_str(), whole_pkt.size());

	return 0;
}

int hexin_stock_broker::send_get_account_balance()
{
	std::string pkt4 = get_account_balance_packet(m_account, m_password, m_account_name, m_sh_gddm_list[0]);
	std::string encrypt_pkt_4 = encrypt_packet(pkt4.c_str(), pkt4.size(), m_session_id, m_packet_index, m_encrypt_key1, m_encrypt_key2, m_decrypt_out_buff);

	std::string head = get_packet_head(encrypt_pkt_4.size());

	std::string whole_pkt = head + encrypt_pkt_4;

	m_socket.send(whole_pkt.c_str(), whole_pkt.size());

	return 0;
}

int hexin_stock_broker::send_get_account_all_order()
{
	std::string pkt9 = get_query_all_contract_packet(m_account, m_password, m_sz_gddm_list[0], '1');
	std::string encrypt_pkt_9 = encrypt_packet(pkt9.c_str(), pkt9.size(), m_session_id, m_packet_index, m_encrypt_key1, m_encrypt_key2, m_decrypt_out_buff);
	std::string head = get_packet_head(encrypt_pkt_9.size());

	std::string whole_pkt = head + encrypt_pkt_9;

	m_socket.send(whole_pkt.c_str(), whole_pkt.size());

	return 0;
}

int hexin_stock_broker::send_buy(const std::string& sid, double price, int quant, const std::string& price_type)
{
	std::string gddm;
	char market = 0;

	if (sid[0] == '6') {
		market = '2';
		gddm = m_sh_gddm_list[0];
	}
	else {
		market = '1';
		gddm = m_sz_gddm_list[0];
	}

	std::string pkt7;
	if (price_type == "limit") {
		pkt7 = get_buy_stock_packet(m_account, m_password, m_account_name, gddm, market, sid, price, quant);
	}
	else if (price_type == "market") {
		pkt7 = get_market_price_buy_packet(m_account, m_password, m_account_name, gddm, market, sid, price, quant);
	}

	std::string encrypt_pkt_7 = encrypt_packet(pkt7.c_str(), pkt7.size(), m_session_id, m_packet_index, m_encrypt_key1, m_encrypt_key2, m_decrypt_out_buff);
	std::string head = get_packet_head(encrypt_pkt_7.size());

	std::string whole_pkt = head + encrypt_pkt_7;

	m_socket.send(whole_pkt.c_str(), whole_pkt.size());

	return 0;
}

int hexin_stock_broker::send_sell(const std::string& sid, double price, int quant, const std::string& price_type)
{
	std::string gddm;
	char market = 0;

	if (sid[0] == '6') {
		market = '2';
		gddm = m_sh_gddm_list[0];
	}
	else {
		market = '1';
		gddm = m_sz_gddm_list[0];
	}

	std::string pkt6;

	if (price_type == "limit") {
		pkt6 = get_sell_stock_packet(m_account, m_password, m_account_name, gddm, market, sid, price, quant);
	}
	else if (price_type == "market") {
		pkt6 = get_market_price_sell_packet(m_account, m_password, m_account_name, gddm, market, sid, price, quant);
	}

	std::string encrypt_pkt_6 = encrypt_packet(pkt6.c_str(), pkt6.size(), m_session_id, m_packet_index, m_encrypt_key1, m_encrypt_key2, m_decrypt_out_buff);
	std::string head = get_packet_head(encrypt_pkt_6.size());

	std::string whole_pkt = head + encrypt_pkt_6;

	m_socket.send(whole_pkt.c_str(), whole_pkt.size());

	return 0;
}

int hexin_stock_broker::send_cancel(const std::string& order_id, const std::string& sid)
{
	std::string gddm;
	char market = 0;

	if (sid[0] == '6') {
		market = '2';
		gddm = m_sh_gddm_list[0];
	}
	else {
		market = '1';
		gddm = m_sz_gddm_list[0];
	}

	std::string pkt8 = get_cancel_packet(m_account, m_password, m_account_name, gddm, market, sid, order_id);
	std::string encrypt_pkt_8 = encrypt_packet(pkt8.c_str(), pkt8.size(), m_session_id, m_packet_index, m_encrypt_key1, m_encrypt_key2, m_decrypt_out_buff);
	std::string head = get_packet_head(encrypt_pkt_8.size());

	std::string whole_pkt = head + encrypt_pkt_8;

	m_socket.send(whole_pkt.c_str(), whole_pkt.size());

	return 0;
}